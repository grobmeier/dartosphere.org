---
title: 'Building a Blog in Dart, Step 1: Serving Files'
layout: post
tags: {  }
category: dartery
published: '2013-12-02T00:37:00-08:00'

---

Earlier I wrote that I was going to write a series on&nbsp;<a href="http://dartery.blogspot.com/2013/11/building-building-blog-in-dart-tutorial.html" target="_blank">Building a Blog in Dart</a>&nbsp;and to start things off we're here with Step 1: Serving Files.<br /><br />The most basic and fundamental thing that any web applications needs to do&nbsp;is serve up HTML over HTTP. Our blog will be completely client-side rendered, but all web applications, no matter how dynamic and client-side rendered, need to serve at least a skeleton HTML page and the script that drives the rendering. We'll start by serving a static HTML page and some basic CSS to show how it works.<br /><h2>A Simple Server</h2>dart:io includes a basic HTTP server which is very easy to use. The most simplified working server that actually serves HTML we could write looks something like this:<br /><br /><pre class="prettyprint lang-dart">import 'dart:io';<br /><br />main() {<br />  HttpServer.bind(InternetAddress.LOOPBACK_IP_V4, 8080).then((server) {<br />    server.listen((req) {<br />      req.response<br />         ..headers.contentType = new ContentType("text", "html")<br />         ..write('<html><body>Hello</body></html>')<br />         ..close();<br />    });<br />  });<br />}<br /></pre><br />Save this as bin/simple.dart in your project and either choose Run&gt;Run in the Editor, or run this from the command line:<br /><br /><pre class="prettyprint">$ dart bin/simple.dart</pre><br />Point your browser at <a href="http://localhost:8080/">http://localhost:8080</a>&nbsp;and you should see this:<br /><br /><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><img border="0" class="noborder" height="404" src="http://3.bp.blogspot.com/--akYSrdvvOA/UpuNFNEmVAI/AAAAAAAAGIc/Qj-SJrVwY34/s640/Screen+Shot+2013-12-01+at+11.19.38+AM.png" width="640" /></div><br /><br />There are a few things to notice here that highlight common patterns you'll see when working in Dart.<br /><br />The first is that the program is completely asynchronous, even the HttpServer setup. main() actually returns before the server is running, but the VM stays alive and the server listens for connections. node.js is famous for its asynchronous, event-driven architecture and APIs, driven by the fact that JavaScript is single-threaded. Dart is similarly single-threaded and the dart:io APIs for networking, file access and working with processes are almost all async.<br /><br />Also, take a look at the documentation for the classes and methods we've used here, like <a href="https://api.dartlang.org/docs/channels/stable/latest/dart_io/HttpServer.html" target="_blank">HttpServer</a>, HttpServer.bind(), <a href="https://api.dartlang.org/docs/channels/stable/latest/dart_io/HttpRequest.html" target="_blank">HttpRequest</a> and HttpRequest.response. Notice the pervasive usage of Future and Stream.<br /><br />HttpServer.bind() returns a Future that completes with the new server when it's constructed. If you ever need to create an object that has dependencies that are resolved asynchronously, this is the way to do it. HttpServer itself implements Steam&lt;HttpRequest&gt;, so it has a listen() method for handling requests, but all the other Stream methods as well, so you can transform and filter the requests if needed. HttpRequest implements Stream&lt;List&lt;int&gt;&gt; for reading the body, and HttpResponse implements <a href="https://api.dartlang.org/docs/channels/stable/latest/dart_async/StreamSink.html" target="_blank">StreamSink</a> and&nbsp;<a href="https://api.dartlang.org/docs/channels/stable/latest/dart_io/IOSink.html" target="_blank">IOSink</a>&nbsp;to write to it. There are many advantages to this approach. First, the APIs are easy to learn, since you'll use those interfaces over and over again in Dart. Second, since the default methods for reading and writing are streaming, you won't run into a situation where you use synchronous APIs and then hit performance or memory issues when transferring very large files, something I've seen with Java servlets. Third, you can use any functions that understand Futures, Streams, IOSink and StreamSink on these classes, which encourages reusable, generic utilities.<br /><h2>Serving a File</h2><div>While inline HTML makes for a short and simple example, it's obviously not how we want to do things. We'd like to keep our HTML, CSS, Dart in separate files, especially so we can edit them with assistance from our favorite editors. dart:io doesn't include a built-in static file handler, but we can easily add our own. (I covered a static file server in&nbsp;<a href="http://dartery.blogspot.com/2012/05/simple-async-http-static-file-server-in.html" target="_blank">A Simple Async HTTP Static File Server in 36 Lines</a>&nbsp;but the APIs have changed, so I'll start fresh).<br /><br />First, we need some HTML:<br /><br /></div><pre class="prettyprint lang-html">&lt;!DOCTYPE html&gt;<br />&lt;html&gt;<br />  &lt;head&gt;<br />    &lt;title&gt;Simple Blog&lt;/title&gt;    <br />  &lt;/head&gt;<br />  &lt;body&gt;<br />    &lt;h1&gt;Simple Blog&lt;/h1&gt;<br />  &lt;/body&gt;<br />&lt;/html&gt;<br /></pre><br />And then our server:<br /><br /><pre class="prettyprint lang-dart">import 'dart:io';<br /><br />main() {<br />  HttpServer.bind(InternetAddress.LOOPBACK_IP_V4, 8080).then((server) {<br />    server.listen((request) {<br />      request.response.headers.contentType = new ContentType("text", "html");<br />      new File('web/client.html').openRead().pipe(request.response);<br />    });<br />  });<br />}<br /></pre><br />Now we're serving the HTML from <span style="font-family: Courier New, Courier, monospace;">web/client.html</span>.<br /><br />We start to see the file APIs in action, and the awesome pluggable nature of Streams again. File.openRead() returns a Stream&lt;List&lt;int&gt;&gt; which we can pipe() directly into the response. This will work well for large files too.<br /><h2 style="font-family: Times; white-space: normal;">Serving Specific URLs</h2><div>The examples above show the same content for any URL, and any HTTP method, because we respond to every request exactly the same way. We need to be able to send different responses for different types of requests, and we'll start by using the Stream API some more to serve some CSS.<br /><br />Stream.where() filters a Stream by a predicate function. We'll use that to only respond to a request if it matches a specific path. Since we want to serve two different paths, we'll a call to where() for each path, and we'll also need a call to handle all other requests, or they will result in a hung request from the browser.<br /><br />Here's the new HTML, CSS and Dart:<br /><br /><pre class="prettyprint lang-html">&lt;!DOCTYPE html&gt;<br />&lt;html&gt;<br />  &lt;head&gt;<br />    &lt;title&gt;Simple Blog&lt;/title&gt;    <br />  &lt;/head&gt;<br />  &lt;body&gt;<br />    &lt;h1&gt;Simple Blog&lt;/h1&gt;<br />  &lt;/body&gt;<br />&lt;/html&gt;<br /></pre><br /><pre class="prettyprint lang-css">body {<br />  background: #cdf;<br />  font-family: Helvetica, Arial;<br />}<br /></pre><br /><pre class="prettyprint lang-dart">import 'dart:io';<br /><br />main() {<br />  HttpServer.bind(InternetAddress.LOOPBACK_IP_V4, 8080).then((server) {<br />    server.asBroadcastStream()<br />      ..where((r) =&gt; r.uri.path == '/').listen((request) {<br />        request.response.headers.contentType = new ContentType("text", "html");<br />        new File('web/client.html').openRead().pipe(request.response);<br />      })<br />      ..where((r) =&gt; r.uri.path == '/client.css').listen((request) {<br />        request.response.headers.contentType = new ContentType("text", "css");<br />        new File('web/client.css').openRead().pipe(request.response);<br />      })<br />      ..where((r) =&gt; r.uri.path != '/' &amp;&amp; r.uri.path != '/client.css').listen((request) {<br />        request.response.statusCode == 404;<br />        request.response.write("Not Found");<br />        request.response.close();<br />      });<br />  });<br />}</pre></div><h2>Better Routing of Requests</h2>This works, but isn't very graceful - we need to handle details like creating a broadcast stream from the server, writing a predicate function rather than specifying the path, and most of all, making sure that the streams we create with where() handle all requests yet are mutually exclusive. This is verbose and prone to error. We can handle these details with a small wrapper on HttpServer, which is exactly what the server-side portion of the <a href="http://pub.dartlang.org/packages/route" target="_blank">route</a> package does.<script>prettyPrint()</script><br /><br />route lets us split the server's stream of requests into streams that only contain request that match a particular URL pattern, and a default stream for requests that don't match any of the patterns making sure that a request is only routed passed to one child stream. It also returns a 404 by default for non-matching requests. Using route our Dart program looks like this:<br /><br /><pre class="prettyprint lang-dart">import 'dart:io';<br />import 'package:route/server.dart';<br /><br />main() {<br />  HttpServer.bind(InternetAddress.LOOPBACK_IP_V4, 8080).then((server) {<br />    new Router(server)<br />      ..serve('/').listen((request) {<br />        request.response.headers.contentType = new ContentType("text", "html");<br />        new File('web/client.html').openRead().pipe(request.response);<br />      })<br />      ..serve('web/client.css').listen((request) {<br />        request.response.headers.contentType = new ContentType("text", "css");<br />        new File('web/client.css').openRead().pipe(request.response);<br />      });<br />  });<br />}</pre><br />That's a little better - less boilerplate and less chance of mistake - but there's still some repetition with the file handing though. If we create a function to generate handlers we can shorten things further:<br /><br /><pre class="prettyprint lang-dart">import 'dart:io';<br />import 'package:route/server.dart';<br />import 'utils.dart' show serveFile;<br /><br />main() {<br />  HttpServer.bind(InternetAddress.LOOPBACK_IP_V4, 8080).then((server) {<br />    new Router(server)<br />      ..serve('/').listen(serveFile('web/client.html'))<br />      ..serve('web/client.css').listen(serveFile('web/client.html'));<br />  });<br />}</pre><br />Much better!<br /><br />We still will need to define our routing to handle URLs for blog posts, our REST API for data and assets, but we'll come back to that later. Also, to avoid going too much into detail about file serving so we can talk about data modeling and UI, I'll skip over serveFile leave it as an exercise for the reader... just until next post, when I'll start hosting example projects on GitHub.<br /><br />Next time we'll look at connecting to a database, defining our data model, and maybe take a look at ORMs.
