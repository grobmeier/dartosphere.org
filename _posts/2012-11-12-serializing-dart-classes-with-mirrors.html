---
title: 'Serializing Dart classes with mirrors'
layout: post
tags:
    - article
category: dartwatch
published: '2012-11-12T21:29:00+00:00'

---

<h2>
Serializing objects with reflection</h2>
I've updated the <a href="https://github.com/chrisbu/dartwatch-JsonObject" target="_blank">JsonObject</a> library to start using the mirrors library to allow serialization from an instance of an object (and child objects, lists of objects and maps of objects) to a JSON string. <br />
This blog post (valid at build 14669) discusses some basic use-cases of the mirror functionality that were used to create the JSON object functionality.<br />
<br />
To show what can be achieved, the following code represents a typical use case: Converting a <span style="font-family: Courier New, Courier, monospace;">Person</span> and a list of <span style="font-family: Courier New, Courier, monospace;">Address</span> instances into JSON text:<br />
<br />
<div style="background: #ffffff; background: white; border-width: .1em .1em .1em .8em; border: solid gray; color: black; overflow: auto; padding: .2em .6em; width: auto;">
<pre style="line-height: 125%; margin: 0;">import <span style="color: blue;">'package:json_object/json_object.dart'</span>;

<span style="color: navy; font-weight: bold;">class</span> Person {
 <span style="color: navy; font-weight: bold;">String</span> name; <span style="color: #008800; font-style: italic;">// simple field</span>

 <span style="color: navy; font-weight: bold;">var</span> _age; <span style="color: #008800; font-style: italic;">// private field</span>
 <span style="color: navy; font-weight: bold;">int</span> <span style="color: navy; font-weight: bold;">get</span> age =&gt; _age; <span style="color: #008800; font-style: italic;">// getter</span>
 <span style="color: navy; font-weight: bold;">set</span> age(value) =&gt; _age = value; <span style="color: #008800; font-style: italic;">// setter</span>

 List&lt;Address&gt; addresses = <span style="color: navy; font-weight: bold;">new</span> List&lt;Address&gt;();
}

<span style="color: navy; font-weight: bold;">class</span> Address {
  <span style="color: navy; font-weight: bold;">String</span> line1;
  <span style="color: navy; font-weight: bold;">String</span> zipcode;
  Address(<span style="color: navy; font-weight: bold;">this</span>.line1, <span style="color: navy; font-weight: bold;">this</span>.zipcode); <span style="color: #008800; font-style: italic;">// constructor</span>
}

<span style="color: navy; font-weight: bold;">void</span> main() {
  <span style="color: navy; font-weight: bold;">var</span> person = <span style="color: navy; font-weight: bold;">new</span> Person();
  person.name = <span style="color: blue;">"Mr Smith"</span>;
  person.age = <span style="color: blue;">30</span>;
  person.addresses.add(<span style="color: navy; font-weight: bold;">new</span> Address(<span style="color: blue;">"1 the street"</span>, <span style="color: blue;">"98765"</span>);
  person.addresses.add(<span style="color: navy; font-weight: bold;">new</span> Address(<span style="color: blue;">"2 a road"</span>, <span style="color: blue;">"87654"</span>);

  <span style="color: navy; font-weight: bold;">var</span> json = objectToJson(person);  <span style="color: #008800; font-style: italic;">// Here is the magic</span>

  print(json); <span style="color: #008800; font-style: italic;">// Valid JSON</span>
}
</pre>
</div>
<br />
The <span style="font-family: Courier New, Courier, monospace;">objectToJson()</span> top level function within the <span style="font-family: Courier New, Courier, monospace;">json_object</span> library uses reflection to iterate through each of the fields and getters of an object (ignoring those that are private or static), and adds each value to an equivalent <span style="font-family: Courier New, Courier, monospace;">Map</span>. &nbsp;Every time it encounters a complex object (ie, not one of <span style="font-family: Courier New, Courier, monospace;">String</span>, <span style="font-family: Courier New, Courier, monospace;">num</span>, <span style="font-family: Courier New, Courier, monospace;">bool</span>, <span style="font-family: Courier New, Courier, monospace;">null</span>), or a <span style="font-family: Courier New, Courier, monospace;">List</span> or <span style="font-family: Courier New, Courier, monospace;">Map</span>, it recurses into itself to convert the entity into another Map. &nbsp;Once it has constructed the map, it calls <span style="font-family: Courier New, Courier, monospace;">JSON.stringify()</span> and returns the final string.<br />
<br />
For the following example, we will use a simplified version of the Person class, containing only the age getter/setter pair, and the name field:<br />
<!-- HTML generated using hilite.me --><br />
<div style="background: #ffffff; background: white; border-width: .1em .1em .1em .8em; border: solid gray; color: black; overflow: auto; padding: .2em .6em; width: auto;">
<pre style="line-height: 125%; margin: 0;"><span style="color: navy; font-weight: bold;">class</span> Person {
 <span style="color: navy; font-weight: bold;">String</span> name; <span style="color: #008800; font-style: italic;">// simple field</span>

 <span style="color: navy; font-weight: bold;">var</span> _age; <span style="color: #008800; font-style: italic;">// private field</span>
 <span style="color: navy; font-weight: bold;">int</span> <span style="color: navy; font-weight: bold;">get</span> age =&gt; _age; <span style="color: #008800; font-style: italic;">// getter</span>
 <span style="color: navy; font-weight: bold;">set</span> age(value) =&gt; _age = value; <span style="color: #008800; font-style: italic;">// setter</span>
}
</pre>
</div>
<br />
Let's see how to serialize this to JSON.<br />
<br />
<h2>
Starting to reflect</h2>
<div>
You can incorporate the reflection library by using importing the dart:mirrors library. &nbsp;We will also need the JSON library.<br />
<!-- HTML generated using hilite.me --><br />
<div style="background: #ffffff; background: white; border-width: .1em .1em .1em .8em; border: solid gray; color: black; overflow: auto; padding: .2em .6em; width: auto;">
<pre style="line-height: 125%; margin: 0;">import <span style="color: blue;">"dart:mirrors"</span>; 
import <span style="color: blue;">"dart:json"</span>;
</pre>
</div>
<br />
This will give you a warning at present that it's not fully implemented.  For this use case you can ignore it.  This gives you access to the top level function <span style="font-family: Courier New, Courier, monospace;">reflect()</span>, into which you pass an instance of an object, for example: <span style="font-family: Courier New, Courier, monospace;">reflect(person); 
</span><br />
This, like looking in a real mirror, shows a reflection of your instance, in the form of an InstanceMirror. &nbsp;You use an <span style="font-family: Courier New, Courier, monospace;">InstanceMirror</span> to examine the specific instance of your object. &nbsp;The instance of your object is &nbsp;accessible via the InstanceMirror.reflectee property:<br />
<br />
<!-- HTML generated using hilite.me --><br />
<div style="background: #ffffff; background: white; border-width: .1em .1em .1em .8em; border: solid gray; color: black; overflow: auto; padding: .2em .6em; width: auto;">
<pre style="line-height: 125%; margin: 0;"><span style="color: #008800; font-style: italic;">// Create an instance of an object</span>
Person person = <span style="color: navy; font-weight: bold;">new</span> Person();
person.name = <span style="color: blue;">"Mr Smith"</span>;
person.age = <span style="color: blue;">30</span>;

<span style="color: navy; font-weight: bold;">var</span> instanceMirror = reflect(person); <span style="color: #008800; font-style: italic;">// Get an instance mirror</span>
print(instanceMirror.reflectee == person); <span style="color: #008800; font-style: italic;">// true</span>
print(instanceMirror.reflectee.name);  <span style="color: #008800; font-style: italic;">// "Mr Smith";</span>
print(instanceMirror.reflectee.age);  <span style="color: #008800; font-style: italic;">// 30;</span>
</pre>
</div>
<br />
<h2>
Accessing values dynamically</h2>
So far, we've not done anything particularly fancy. Our ultimate goal is to access each of the values dynamically, so that we can store the field names (as keys) and values in a dynamically populated map. &nbsp;We'll call our map <span style="font-family: Courier New, Courier, monospace;">objectMap</span>.<br />
To access the fields by string, you can pass the field name into the <span style="font-family: Courier New, Courier, monospace;">getField()</span> method of the <span style="font-family: Courier New, Courier, monospace;">InstanceMirror</span>. &nbsp;This returns a Future for "variables" (in Mirror parlance) such as <span style="font-family: Courier New, Courier, monospace;">person.name</span>, and getters, such as <span style="font-family: Courier New, Courier, monospace;">person.age</span>.<br />
<!-- HTML generated using hilite.me --><br />
<div style="background: #ffffff; background: white; border-width: .1em .1em .1em .8em; border: solid gray; color: black; overflow: auto; padding: .2em .6em; width: auto;">
<pre style="line-height: 125%; margin: 0;"><span style="color: navy; font-weight: bold;">var</span> objectMap = <span style="color: navy; font-weight: bold;">new</span> Map&lt;string,dynamic&gt;();
map[<span style="color: blue;">"name"</span>] = instanceMirror.getField(<span style="color: blue;">"name"</span>); 
map[<span style="color: blue;">"age"</span>] = instanceMirror.getField(<span style="color: blue;">"age"</span>); 
print(objectMap); <span style="color: #008800; font-style: italic;">// {name: Instance of '_FutureImpl@0x127eafe4', </span>
                  <span style="color: #008800; font-style: italic;">//  age: Instance of '_FutureImpl@0x127eafe4'}</span>
</pre>
</div>
<br />
As you can see, the <span style="font-family: Courier New, Courier, monospace;">getField()</span> function returns a <span style="font-family: Courier New, Courier, monospace;">Future</span>&nbsp;rather than the actual value&nbsp;(as pointed out in the comments - calls to <span style="font-family: Courier New, Courier, monospace;">getField()</span> are currently implemented in a synchronous fashion, however the fact that they return futures means that we should deal with them as though they are async).  Our task is to convert the property values that will ultimately appear in the Future's <span style="font-family: Courier New, Courier, monospace;">onComplete</span> handler into a map of key, value pairs that we can serialize to JSON.  Fortunately, the Futures library contains a <span style="font-family: Courier New, Courier, monospace;">wait(List&lt;Future&gt;)</span> function, that we can use to wait for all the futures to complete.<br />
<br />
The following refactored code sample performs the following steps:<br />
1. Use the <span style="font-family: Courier New, Courier, monospace;">onComplete</span> event of each future to store the completed value in the objectMap<br />
2. Use the <span style="font-family: Courier New, Courier, monospace;">wait()</span> function to wait for all values to be retrieved <br />
(But we are not quite finished)...<br />
<!-- HTML generated using hilite.me --><br />
<div style="background: #ffffff; background: white; border-width: .1em .1em .1em .8em; border: solid gray; color: black; overflow: auto; padding: .2em .6em; width: auto;">
<pre style="line-height: 125%; margin: 0;"><span style="color: navy; font-weight: bold;">var</span> objectMap = <span style="color: navy; font-weight: bold;">new</span> Map();

<span style="color: navy; font-weight: bold;">var</span> nameFuture = instanceMirror.getField(<span style="color: blue;">"name"</span>);  <span style="color: #008800; font-style: italic;">// retrieve a Future</span>
<span style="color: #008800; font-style: italic;">
</span></pre>
<pre style="line-height: 125%; margin: 0;"><span style="color: #008800; font-style: italic;">// when the future completetes, insert the retrieved value into the map</span>
nameFuture.onComplete((futureValue) =&gt; objectMap[<span style="color: blue;">"name"</span>] = futureValue.value);

<span style="color: navy; font-weight: bold;">var</span> ageFuture = instanceMirror.getField(<span style="color: blue;">"age"</span>); 
ageFuture.onComplete((futureValue) =&gt; objectMap[<span style="color: blue;">"age"</span>] = futureValue.value);

<span style="color: #008800; font-style: italic;">// Wait for the futures to complete</span>
Futures.wait([nameFuture,ageFuture]).then((f) { <span style="color: #008800; font-style: italic; line-height: 125%;">// List of Futures</span>

  print(objectMap); <span style="color: #008800; font-style: italic;">// {name: InstanceMirror on &lt;'Mr Smith'&gt;,&nbsp;</span></pre>
<pre style="line-height: 125%; margin: 0;"><span style="color: #008800; font-style: italic;">                   //  age: InstanceMirror on &lt;30&gt;}</span>
</pre>
<pre style="line-height: 125%; margin: 0;"><pre>});</pre>
</pre>
</div>
<br />
We are still not quite done, as the Future does not return the the class's property value - remember, we are dealing with the reflection, of a Person, not the person itself. &nbsp;When the futures complete, they each return an instance mirror. &nbsp;As noted above, we can access the reflected item by looking at the InstanceMirror's reflectee property, as shown in the refactored code below:
<br />
<!-- HTML generated using hilite.me --><br />
<div style="background: #ffffff; background: white; border-width: .1em .1em .1em .8em; border: solid gray; color: black; overflow: auto; padding: .2em .6em; width: auto;">
<pre style="line-height: 125%; margin: 0;"><span style="color: navy; font-weight: bold;">var</span> objectMap = <span style="color: navy; font-weight: bold;">new</span> Map();

<span style="color: navy; font-weight: bold;">var</span> nameFuture = instanceMirror.getField(<span style="color: blue;">"name"</span>);  <span style="color: #008800; font-style: italic;">// retrieve a Future</span>
<span style="color: #008800; font-style: italic;">// when the future completetes, insert the retrieved value into the map</span>
nameFuture.onComplete((futureValue) {
  <span style="color: navy; font-weight: bold;">var</span> actualValue = futureValue.value.reflectee; <span style="color: #008800; font-style: italic;">// access the actual value </span>
                                                 <span style="color: #008800; font-style: italic;">// from the InstanceMirror</span>
  objectMap[<span style="color: blue;">"name"</span>] = actualValue; <span style="color: #008800; font-style: italic;">// store the actual value</span>
}); 

<span style="color: navy; font-weight: bold;">var</span> ageFuture = instanceMirror.getField(<span style="color: blue;">"age"</span>); 
<span style="color: #008800; font-style: italic;">// shorthand version below:</span>
ageFuture.onComplete((futureValue) =&gt; objectMap[<span style="color: blue;">"age"</span>] = futureValue.value.reflectee);

<span style="color: #008800; font-style: italic;">// Wait for the futures to complete</span>
Futures.wait([nameFuture,ageFuture]).then((f) { <span style="color: #008800; font-style: italic;">// List of Futures</span>

  print(objectMap); <span style="color: #008800; font-style: italic;">// {name: Mr Smith, age: 30}</span>
  print(JSON.stringify(objectMap)); <span style="color: #008800; font-style: italic;">// Valid JSON: 
                                    // {"name":"Mr Smith","age":30}</span>
</pre>
<pre style="line-height: 125%; margin: 0;"><pre>});</pre>
</pre>
</div>
<br />
Now that you have accessed the person.name and person.age values from a standard Dart class, using string values to access the properties, we need to make this a little more dynamic. &nbsp;What we really need is a list of these strings, so that we can iterate through them calling <span style="font-family: Courier New, Courier, monospace;">getField()</span> on each. &nbsp;That's next... <br />
<br />
<h2>
Dynamically accessing the members</h2>
</div>
<div>
When working with mirrors, you can find out information about you <span style="font-family: Courier New, Courier, monospace;">InstanceMirror</span> by examining it's type property. &nbsp;The type property returns a <span style="font-family: Courier New, Courier, monospace;">ClassMirror</span>. Unlike the <span style="font-family: Courier New, Courier, monospace;">InstanceMirror</span> (which is concerned with the specific instance), the <span style="font-family: Courier New, Courier, monospace;">ClassMirror</span> can provide you with information about the Class, such as its fields. &nbsp;</div>
<div>
The <span style="font-family: Courier New, Courier, monospace;">ClassMirror</span> has two <span style="font-family: Courier New, Courier, monospace;">Map</span> properties that we are interested in: <span style="font-family: Courier New, Courier, monospace;">.getters</span>&nbsp;and <span style="font-family: Courier New, Courier, monospace;">.variables</span>. &nbsp;The keys are the field names, and the values are instances of &nbsp;<span style="font-family: Courier New, Courier, monospace;">VariableMirror</span> or <span style="font-family: Courier New, Courier, monospace;">MethodMirror</span>. &nbsp;The getters map returns <span style="font-family: Courier New, Courier, monospace;">MethodMirror</span>, and the variables map returns <span style="font-family: Courier New, Courier, monospace;">VariableMirror</span>, which we will soon use to find out important information about our fields. &nbsp;For the moment, let's refactor our code to dynamically populate the object map based upon getters (of which the <span style="font-family: Courier New, Courier, monospace;">person.age</span> is one):
<br />
<!-- HTML generated using hilite.me --><br />
<div style="background: #ffffff; background: white; border-width: .1em .1em .1em .8em; border: solid gray; color: black; overflow: auto; padding: .2em .6em; width: auto;">
<pre style="line-height: 125%; margin: 0;"><span style="color: navy; font-weight: bold;">var</span> objectMap = <span style="color: navy; font-weight: bold;">new</span> Map();

<span style="color: navy; font-weight: bold;">var</span> futureValuesList = <span style="color: navy; font-weight: bold;">new</span> List();

<span style="color: navy; font-weight: bold;">var</span> classMirror = instanceMirror.type;
classMirror.getters.keys.forEach((key) {
  <span style="color: navy; font-weight: bold;">var</span> future = instanceMirror.getField(key);
  future.onComplete((futureValue) {
    <span style="color: navy; font-weight: bold;">var</span> actualValue = futureValue.value.reflectee; <span style="color: #008800; font-style: italic;">// extract the actual value</span>
    objectMap[key] = actualValue; <span style="color: #008800; font-style: italic;">// store the actual value in the map, keyed with</span>
                                  <span style="color: #008800; font-style: italic;">// the same name as the getter</span>
  });
  futureValuesList.add(future); <span style="color: #008800; font-style: italic;">// add the future to the list.</span>
});

<span style="color: #008800; font-style: italic;">// Wait for the futures to complete</span>
Futures.wait(futureValuesList).then((f) { <span style="color: #008800; font-style: italic;">// List of Futures (contains age).</span>

  print(objectMap); <span style="color: #008800; font-style: italic;">// {age: 30}</span>
  print(JSON.stringify(objectMap)); <span style="color: #008800; font-style: italic;">// Valid JSON: {"age":30}
</span><pre>});</pre>
</pre>
</div>
<br />
There is only one getter, so we also need to iterate through the <span style="font-family: Courier New, Courier, monospace;">keys</span> of the <span style="font-family: Courier New, Courier, monospace;">variables</span> map of the <span style="font-family: Courier New, Courier, monospace;">ClassMirror</span>. &nbsp;This presents us with a small problem, as the variables map also contains private variables, such as <span style="font-family: Courier New, Courier, monospace;">_age</span><span style="font-family: inherit;"> (which we have already dealt with by using the </span><span style="font-family: Courier New, Courier, monospace;">getters</span><span style="font-family: inherit;"> map. &nbsp;The following line outputs the names of each of the variable keys that are reflected from the Person class:
</span><br />
<!-- HTML generated using hilite.me --><br />
<div style="background: #ffffff; background: white; border-width: .1em .1em .1em .8em; border: solid gray; color: black; overflow: auto; padding: .2em .6em; width: auto;">
<pre style="line-height: 125%; margin: 0;">  classMirror.variables.forEach((key,value) =&gt; print(key)); <span style="color: #008800; font-style: italic;">// _age</span>
                                                            <span style="color: #008800; font-style: italic;">// name</span>
</pre>
</div>
<br />
Each of the values are instances of <span style="font-family: Courier New, Courier, monospace;">VariableMirror</span>, and we can use <span style="font-family: Courier New, Courier, monospace;">VariableMirror</span><span style="font-family: inherit;"> (and likewise, &nbsp;</span><span style="font-family: Courier New, Courier, monospace;">MethodMirror</span><span style="font-family: inherit;">&nbsp;from the </span><span style="font-family: Courier New, Courier, monospace;">getters</span><span style="font-family: inherit;"> map if we so desire) to find out if the variable is a private member by checking the </span><span style="font-family: Courier New, Courier, monospace;">isPrivate</span><span style="font-family: inherit;"> flag. &nbsp;We only want to serialize to JSON properties that are not private, so we will add an if statement to only use the public keys from the variables map.</span>
<br />
<!-- HTML generated using hilite.me --><br />
<div style="background: #ffffff; background: white; border-width: .1em .1em .1em .8em; border: solid gray; color: black; overflow: auto; padding: .2em .6em; width: auto;">
<pre style="line-height: 125%; margin: 0;">classMirror.variables.forEach((key,VariableMirror value) {
  <span style="color: navy; font-weight: bold;">if</span> (!value.isPrivate) { <span style="color: #008800; font-style: italic;">// only get the value if it is public</span>
    <span style="color: navy; font-weight: bold;">var</span> future = instanceMirror.getField(key);
    future.onComplete((futureValue) {
       objectMap[key] = futureValue.value.reflectee;
    });
    futureValuesList.add(future); <span style="color: #008800; font-style: italic;">// add the future to the list.</span>
  }
});
</pre>
</div>
<br />
And that's it.  We can now serialize a simple class.<br />
<br />
<h2>
&nbsp;Full Sample Code</h2>
Let's take one final look at the complete code (you should be able to paste this into the Dart Editor and run it.
<br />
<!-- HTML generated using hilite.me --><br />
<div style="background: #ffffff; background: white; border-width: .1em .1em .1em .8em; border: solid gray; color: black; overflow: auto; padding: .2em .6em; width: auto;">
<pre style="line-height: 125%; margin: 0;">import <span style="color: blue;">"dart:mirrors"</span>;
import <span style="color: blue;">"dart:json"</span>;

<span style="color: navy; font-weight: bold;">class</span> Person {
 <span style="color: navy; font-weight: bold;">String</span> name; <span style="color: #008800; font-style: italic;">// simple field</span>

 <span style="color: navy; font-weight: bold;">var</span> _age; <span style="color: #008800; font-style: italic;">// private field</span>
 <span style="color: navy; font-weight: bold;">int</span> <span style="color: navy; font-weight: bold;">get</span> age =&gt; _age; <span style="color: #008800; font-style: italic;">// getter</span>
 <span style="color: navy; font-weight: bold;">set</span> age(value) =&gt; _age = value; <span style="color: #008800; font-style: italic;">// setter</span>
}

<span style="color: navy; font-weight: bold;">void</span> main() {
  <span style="color: navy; font-weight: bold;">var</span> person = <span style="color: navy; font-weight: bold;">new</span> Person();
  person.name = <span style="color: blue;">"Mr Smith"</span>;
  person.age = <span style="color: blue;">30</span>;
  <span style="color: navy; font-weight: bold;">var</span> instanceMirror = reflect(person);
  print(instanceMirror.reflectee == person); <span style="color: #008800; font-style: italic;">// true</span>
  print(instanceMirror.reflectee.name);  <span style="color: #008800; font-style: italic;">// "Mr Smith";</span>
  print(instanceMirror.reflectee.age);  <span style="color: #008800; font-style: italic;">// 30;</span>

  <span style="color: navy; font-weight: bold;">var</span> objectMap = <span style="color: navy; font-weight: bold;">new</span> Map();

  <span style="color: navy; font-weight: bold;">var</span> futureValuesList = <span style="color: navy; font-weight: bold;">new</span> List();

  <span style="color: navy; font-weight: bold;">var</span> classMirror = instanceMirror.type;

  classMirror.getters.keys.forEach((key) {
    <span style="color: navy; font-weight: bold;">var</span> future = instanceMirror.getField(key);
    future.onComplete((futureValue) {
      <span style="color: navy; font-weight: bold;">var</span> actualValue = futureValue.value.reflectee; <span style="color: #008800; font-style: italic;">// extract the actual value</span>
      objectMap[key] = actualValue; <span style="color: #008800; font-style: italic;">// store the actual value in the map, keyed with</span>
      <span style="color: #008800; font-style: italic;">// the same name as the getter</span>
    });
    futureValuesList.add(future); <span style="color: #008800; font-style: italic;">// add the future to the list.</span>
  });

  classMirror.variables.forEach((key,VariableMirror value) {
    <span style="color: navy; font-weight: bold;">if</span> (!value.isPrivate) { <span style="color: #008800; font-style: italic;">// only get the value if it is public</span>
      <span style="color: navy; font-weight: bold;">var</span> future = instanceMirror.getField(key);
      future.onComplete((futureValue) {
        objectMap[key] = futureValue.value.reflectee;
      });
      futureValuesList.add(future); <span style="color: #008800; font-style: italic;">// add the future to the list.</span>
    }
  });

  <span style="color: #008800; font-style: italic;">// Wait for the futures to complete</span>
  Futures.wait(futureValuesList).then((f) { <span style="color: #008800; font-style: italic;">// List of Futures</span>

  print(objectMap); <span style="color: #008800; font-style: italic;">// {age: 30}</span>
  print(JSON.stringify(objectMap)); <span style="color: #008800; font-style: italic;">// Valid JSON: 
                                    // {"name":"Mr Smith", "age":30}
</span><pre>  });</pre>
}
</pre>
</div>
<br />
<h2>
JsonObject's objectToJson() function

</h2>
</div>
<div>
<a href="https://github.com/chrisbu/dartwatch-JsonObject" target="_blank">JsonObject </a>uses code similar to that demonstrated above to serialize Lists of objects, Maps of objects, and objects containing other objects (or lists and maps of objects). &nbsp;By using recursion, it is able to convert deeply nested hierarchies of objects to a JSON string. &nbsp;Take a look at the <a href="https://github.com/chrisbu/dartwatch-JsonObject/blob/master/test/test_mirrors_serialize.dart" target="_blank">unit tests</a> on github for some examples, or the full source code in the <a href="https://github.com/chrisbu/dartwatch-JsonObject/blob/master/lib/src/mirror_based_serializer.dart" target="_blank">mirror_based_serializer.dart</a> class. &nbsp;This has a top-level function called <span style="font-family: Courier New, Courier, monospace;">objectToSerializeable()</span>, which returns something (such as a map or list) that can be serialized by <span style="font-family: Courier New, Courier, monospace;">JSON.stringify()</span><span style="font-family: inherit;">, and is called by the </span><span style="font-family: Courier New, Courier, monospace;">objectToJson()</span><span style="font-family: inherit;">&nbsp;function that lives in the main json_object library file.</span><br />
<span style="font-family: inherit;">Next steps for me is to add deserialization of a JSON string into a real class. &nbsp;But that's the subject of another blog post.</span></div>
<div>
<br /></div>
<h2>
But...</h2>
<div>
The only downside (at present) with using mirrors, is that it doesn't work with dart2js - so this is restricted to server-side or Dartium code only. &nbsp;See <a href="https://groups.google.com/a/dartlang.org/d/topic/misc/6SwESxJS4F4/discussion" target="_blank">this post on the Dartlang google groups</a> for more information.</div>
<div>
<br /></div>
<h2>
Further reading</h2>
<div>
<ul>
<li><a href="http://phylotic.blogspot.co.uk/2012/08/working-with-mirrors-in-dart-brief.html" target="_blank">John Evan's post on Mirrors</a></li>
<li><a href="http://bracha.org/mirrors.pdf" target="_blank">Gilad Bracha's paper on Mirror based reflection</a></li>
<li><a href="http://api.dartlang.org/docs/bleeding_edge/dart_mirrors/InstanceMirror.html" target="_blank">API docs for InstanceMirror</a></li>
<li><a href="http://api.dartlang.org/docs/bleeding_edge/dart_core/Future.html" target="_blank">API docs for Futures</a></li>
<li><a href="http://news.dartlang.org/2012/08/learn-about-mirrors-and-isolates-in.html" target="_blank">Dartisans video Episode 9</a> (about Mirrors)</li>
</ul>
<h2>
Don't forget...</h2>
</div>
<div style="text-align: center;">
<a href="http://goo.gl/XhCW7" target="_blank"><b>Check out my book. Dart in Action, from Manning Publications</b></a></div>
<div>
<br /></div>
<div class="separator" style="clear: both; text-align: center;">
<a href="http://goo.gl/XhCW7" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-dCjmEpK6Ry0/UKFpw3XOX-I/AAAAAAAACYE/b-H6cOZz6FQ/s1600/Buckett-Dart-fc-small-blog.png" /></a></div>
<div>
<br /></div>
<div class="feedflare">
<a href="http://feeds.feedburner.com/~ff/Dartwatch?a=MZJCgXs0Abg:5sk8rEtxWMM:yIl2AUoC8zA"><img src="http://feeds.feedburner.com/~ff/Dartwatch?d=yIl2AUoC8zA" border="0"></img></a> <a href="http://feeds.feedburner.com/~ff/Dartwatch?a=MZJCgXs0Abg:5sk8rEtxWMM:V_sGLiPBpWU"><img src="http://feeds.feedburner.com/~ff/Dartwatch?i=MZJCgXs0Abg:5sk8rEtxWMM:V_sGLiPBpWU" border="0"></img></a> <a href="http://feeds.feedburner.com/~ff/Dartwatch?a=MZJCgXs0Abg:5sk8rEtxWMM:qj6IDK7rITs"><img src="http://feeds.feedburner.com/~ff/Dartwatch?d=qj6IDK7rITs" border="0"></img></a> <a href="http://feeds.feedburner.com/~ff/Dartwatch?a=MZJCgXs0Abg:5sk8rEtxWMM:63t7Ie-LG7Y"><img src="http://feeds.feedburner.com/~ff/Dartwatch?d=63t7Ie-LG7Y" border="0"></img></a> <a href="http://feeds.feedburner.com/~ff/Dartwatch?a=MZJCgXs0Abg:5sk8rEtxWMM:F7zBnMyn0Lo"><img src="http://feeds.feedburner.com/~ff/Dartwatch?i=MZJCgXs0Abg:5sk8rEtxWMM:F7zBnMyn0Lo" border="0"></img></a>
</div><img src="http://feeds.feedburner.com/~r/Dartwatch/~4/MZJCgXs0Abg" height="1" width="1"/>
