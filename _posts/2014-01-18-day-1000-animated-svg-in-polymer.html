---
title: 'Day 1000: Animated SVG in Polymer'
layout: post
tags:
    - animation
    - chain
    - dart
    - dartlang
    - polymer
    - svg
category: japhr-by-chris-strom
published: '2014-01-18T23:44:00-05:00'

---

<div class=top-chain-links></div><br />For an ostensibly UI facing library, I have done almost no UI work while researching <a href="http://patternsinpolymer.com">Patterns in Polymer</a>. I think that speaks to the hidden power of coding with the library. Even so, it is a web based, UI library, so I ought to do some UI-like things. Enter last night's <code>&lt;x-pizza></code> tag—the SVG based pizza builder:<br /><br /><a href="http://2.bp.blogspot.com/-UJW3itsnbtc/UtqcwmlFQ2I/AAAAAAAAU3I/NgV6lMFS2Mg/s1600/01-x_pizza_the_svg_pizza_builder.png" imageanchor="1" ><img border="0" src="http://2.bp.blogspot.com/-UJW3itsnbtc/UtqcwmlFQ2I/AAAAAAAAU3I/NgV6lMFS2Mg/s640/01-x_pizza_the_svg_pizza_builder.png" /></a><br /><br />The pizza SVG in this Polymer is built by passing a “maker” function, which makes individual toppings (e.g. pepperoni), into add-topping methods:<pre class=prettyprint>@CustomTag('x-pizza')<br />class XPizza extends PolymerElement {<br />  // ...<br />  _addFirstHalfTopping(maker) {<br />    for (var i=0; i&lt;20; i++) {<br />      var angle = 2 * PI * _rand.nextDouble();<br />      var u = _rand.nextDouble() + _rand.nextDouble();<br />      var distance = 125 * ((u &lt; 1.0) ? u : 2-u);<br /><br />      var topping = maker()<br />        ..attributes.addAll({<br />            'cx': "${150 - (distance * sin(angle)).abs()}",<br />            'cy': "${150 + (distance * cos(angle))}"<br />          });<br /><br />      $['pizza-graphic'].append(topping);<br />    }<br />  }<br />  // ...<br />}</pre>It is a little hard to randomly distribute things in a circle, but happily there is <a href="http://stackoverflow.com/questions/5837572/generate-a-random-point-within-a-circle-uniformly">Stack Overflow</a>, which is the source for most of that.<br /><br />It is nice to see the pizza built and all, but I would like to give hungry buyers more of a sense of building their own pizzas. Animating the toppings coming in from the side and dropping onto the pizza should do that nicely. I have no idea if that is possible with SVG, but there is one way to find out...<br /><br />I start by grouping the toppings in an SVG <code>&lt;g></code> element. It turns out that you cannot set <code>cx</code> and <code>cy</code> attributes on group elements. Instead you have to translate them in a transform (that's gonna be easy to remember):<pre class=prettyprint><code>  _addFirstHalfTopping(maker) {<br /><b>    var group = new GElement()<br />      ..attributes = {'transform': 'translate(150,150)'};</b><br /><br />    for (var i=0; i&lt;20; i++) {<br />      var angle = 2 * PI * _rand.nextDouble();<br />      var u = _rand.nextDouble() + _rand.nextDouble();<br />      var distance = 125 * ((u &lt; 1.0) ? u : 2-u);<br /><br />      var topping = maker()<br />        ..attributes.addAll({<br />            'cx': "${-(distance * sin(angle)).abs()}",<br />            'cy': "${ (distance * cos(angle))}"<br />          });<br /><br /><b>      group.append(topping);</b><br />    }<br /><b>    $['pizza-graphic'].append(group);</b><br />  }</code></pre>I have my toppings grouped and can position them together. How about animating?<br /><br />Unfortunately, the <code>&lt;animate*></code> tags do not seem to work too well when trying to dynamically start animations. The <code>&lt;animateMotion></code> tag almost works… some of the time… when you don't hit reload too fast or stare at the page funny:<pre class="prettyprint"><code>  _addFirstHalfaTopping(maker) {<br />    // ...<br />    $['pizza-graphic'].append(group);<br />    group..append(<br /><b>          new AnimateMotionElement()..attributes = {<br />            'from': '0, 150',<br />            'to':   '150, 150',<br />            'dur':  '3s',<br />            'fill': 'freeze'<br />          }</b><br />        );<br /><br />  }</code></pre>For whatever reason, that does not seem reliable and fails to work at all on Firefox. So it seems that I need to revisit my old friend <code>requestAnimationFrame()</code>. I have honestly been missing this since <a href="http://gamingJS.com">3D Game Programming for Kids</a> went to press, so I may be reaching for a golden hammer here. But I don't care, animation frames, which are functions that get called when the browser signals it is ready to paint, are cool.<br /><br />It seems that <a href="http://dartlang.org">Dart</a> has a future-based take on animation frames. Given an <code>animate()</code> function, I can ask the browser to call it with <code>window.animationFrame.then(animate)</code>. The function that animates pizza toppings sliding in from the side over the course of 1.5 seconds is then:<pre class="prettyprint"><code>  _addFirstHalfaTopping(maker) {<br />    // ...<br />    $['pizza-graphic'].append(group);<br /><b>    var start;<br />    int dur = 1500;<br />    animate(time) {<br />      if (start == null) start = time;<br />      if (time - start > dur) return;<br />      var x = 150 * (time - start) / dur;<br />      group.attributes['transform'] = 'translate(${x.toInt()}, 150)';<br /><br />      window.animationFrame.then(animate);<br />    };<br />    window.animationFrame.then(animate);</b><br />  }<br /></code></pre>That does the trick. Just as with the JavaScript <code>requestAnimationFrame()</code>, I have to request the <code>animate()</code> function once and then recursively call it from within <code>animate()</code> afterwards to keep the animation running. The effect is a nice, smooth animation that starts with the toppings floating in from the side:<br /><br /><a href="http://3.bp.blogspot.com/-3xUru6A2MOU/Uts97GRkwwI/AAAAAAAAU3Y/ZiLM_aTKl6s/s1600/02-start_animation.png" imageanchor="1" ><img border="0" src="http://3.bp.blogspot.com/-3xUru6A2MOU/Uts97GRkwwI/AAAAAAAAU3Y/ZiLM_aTKl6s/s640/02-start_animation.png" /></a><br /><br />And settling down nicely:<br /><br /><a href="http://1.bp.blogspot.com/-0yxfDjsB5tg/Uts97dyiE5I/AAAAAAAAU3c/IyrD75EcCU0/s1600/03-end_animation.png" imageanchor="1" ><img border="0" src="http://1.bp.blogspot.com/-0yxfDjsB5tg/Uts97dyiE5I/AAAAAAAAU3c/IyrD75EcCU0/s640/03-end_animation.png" /></a><br /><br />For completeness' sake, I animate the toppings falling gently, like a mother putting a babe down to rest, at the end of the left-to-right animation:<pre class="prettyprint"><code>  _addFirstHalfaTopping(maker) {<br />    // ...<br />    $['pizza-graphic'].append(group);<br /><b>    var start_y;<br />    int dur_y = 500;<br />    animateY(time) {<br />      if (start_y == null) start_y = time;<br />      if (time - start_y > dur_y) return;<br /><br />      var x = 150;<br />      var y = 140 + 10 * sin(0.5 * PI * (time - start_y) / dur_y);<br /><br />      group.attributes['transform'] = 'translate(${x}, ${y.toInt()})';<br /><br />      window.animationFrame.then(animateY);<br />    }</b><br /><br />    var start_x;<br />    int dur_x = 1500;<br />    animateX(time) {<br />      if (start_x == null) start_x = time;<br /><b>      if (time - start_x > dur_x) return window.animationFrame.then(animateY);</b><br />      // ...<br />    };<br /><br />    window.animationFrame.then(animateX);<br />  }</code></pre>My code has serious longer-than-my-arm code smell at this point, but it works!<br /><br />I call it a night here. Up tomorrow either the JavaScript implementation of this SVG Polymer or, if that proves trivial, I will move on to playing with Angular and Polymer together.<br /><br /><span style="color: #ccc">Day #1000</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/01/day-999-polymer-and-svg.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <a href="http://japhr.blogspot.com/2014/01/day-1001-getting-started-with-angular.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script>
