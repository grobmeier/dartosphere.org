---
title: 'Dart Transformers for Polymer Cleanup'
layout: post
tags:
    - chain
    - dart
    - dartlang
    - i18n
    - polymer
    - transformer
category: japhr-by-chris-strom
published: '2013-12-29T23:58:00-05:00'

---

<div class=top-chain-links></div><br />All right, I really like this approach to loading configuration data in <a href="http://www.polymer-project.org/">Polymer</a> applications:<pre class="prettyprint"><code><b>&lt;link rel="import" href="hello-you-en.json"><br />&lt;link rel="import" href="hello-you-fr.json"><br />&lt;link rel="src" href="hello-you-es.json"></b><br />&lt;polymer-element name="hello-you"><br />  &lt;!-- Polymer definition here --><br />&lt;/polymer-element></code></pre>The Polymer polyfill code makes sure that this JSON data is imported just like Polymer code that might otherwise go there. In JavaScript, I can then work through the Polymer's <code>element</code> property to access the definition and these data files:<pre class=prettyprint><code>        var list = this.<br />          element.<br />          parentElement.<br />          querySelectorAll('link[rel=import]').<br />          array().<br />          filter(function(el) {<br />            return el.href.match(/hello-you-\w+.json/)<br />          });</code></pre>The nice thing about this approach is that the imports are guaranteed to be loaded before the Polymer code executes. There is no need for futures, promises or callbacks. It is ready when the Polymer is ready. Nice!<br /><br />Only it does not quite work in <a href="https://www.dartlang.org/polymer-dart/">Polymer.dart</a>, the <a href="http://dartlang.org">Dart</a> version of the library. For one thing there is no <code>element</code> property. There is a <code>declaration</code> property which does nearly the same thing, but does not include access to elements outside of the <code>&lt;polymer-element></code> tag (I am pretty sure that is a bug). But, what does work is moving the <code>&lt;link></code> tags inside the <code>&lt;polymer-element></code> definition:<pre class=prettyprint>&lt;polymer-element name="hello-you"><br /><b>  &lt;link rel="import" href="hello-you-en.json"><br />  &lt;link rel="import" href="hello-you-fr.json"><br />  &lt;link rel="import" href="hello-you-es.json"></b><br />  &lt;!-- Polymer definition here... --><br />&lt;/polymer-element></pre>I can then query the import data <sup><a href="#fn-1">*</a></sup> through the <code>declaration</code> property that refused me access to these <code>&lt;link></code> imports when they resided outside the <code>&lt;polymer-element></code>:<pre class="prettyprint">@CustomTag('hello-you')<br />class HelloYou extends PolymerElement {<br />  // ...<br />  ready() {<br />    super.ready();<br /><br />    var re = new RegExp(r'hello-you-(\w+).json');<br /><b>    var list = declaration.<br />      parent.<br />      querySelectorAll('link[rel=import]').<br />      where((el)=> el.href.contains(re));</b><br />    // ...<br />  }<br />}</pre>This is not ideal, but I can live with this. At least until I can convince the fine Polymer.dart folks that the <code>declaration</code> property (if they keep it) should include extra-<code>&lt;polymer-element></code> access.<br /><br />What I cannot live with is what the Polymer “transformer” does to these <code>&lt;link></code> imports of JSON data. The transformer, which transforms the page into something closely resembling a thing that can be deployed (but that can also include debug code for local development), winds up including the JSON data directly in the page:<br /><br /><a href="http://1.bp.blogspot.com/-E0xDYg4z6Dc/UsDV2Gh3kdI/AAAAAAAAUsw/ogmg2tZ4-Cc/s1600/01-imported_json.png" imageanchor="1" ><img border="0" src="http://1.bp.blogspot.com/-E0xDYg4z6Dc/UsDV2Gh3kdI/AAAAAAAAUsw/ogmg2tZ4-Cc/s640/01-imported_json.png" /></a><br /><br />There are any number of things that I could do to get around this, but since, this residue is created by Polymer's transformer, writing my own transformer seems like a fine way of dealing with this. But how the heck do you write a transformer in Dart?<br /><br />To answer that question, I dig through the Polymer code a bit. The transformer in there is named <code>transformer.dart</code>. I am unsure if the name is significant, but, assuming that it is, I create a <code>lib/transformer.dart</code> code file in my application. I eventually trace the Polymer code back to the Pub <code>barback</code> package, which defines the <code>Transformer</code> baseclass. So my <code>lib/transformer.dart</code> code starts as:<pre class="prettyprint">library i18n_example.transformer;<br /><br />import 'package:barback/barback.dart';<br /><br />class ScrubJsonImports extends Transformer {<br />  ScrubJsonImports.asPlugin(BarbackSettings settings);<br /><br />  Future apply(Transform transform) {<br />    print('here');<br />  }<br />}</pre>The <code>asPlugin()</code> named constructor turns out to be necessary to get <code>pub serve</code> to start. To try this skeleton transformer out, I add it to my application's <code>pubspec.yaml</code>:<pre class=prettyprint>name: i18n_example<br />dependencies:<br />  polymer: any<br />  polymer_elements: any<br />  intl: any<br />dev_dependencies:<br />  unittest: any<br />transformers:<br />- polymer:<br />    entry_points: web/index.html<br /><b>- i18n_example:<br />    entry_points: web/index.html</b></pre>I add it after the Polymer transformer because I want to fix Polymer's transformer output (it is also possible to run transformers in parallel).<br /><br />It is when running my transformer with <code>pub serve</code> that I find that I need the <code>asPlugin()</code> named constructor. Without it, I get:<pre class="prettyprint">$ pub serve<br />No transformers that accept configuration were defined in package:i18n_example/transformer.dart or package:i18n_example/i18n_example.dart,<br />required by i18n_example.</pre>Also, it does seem that the name <code>transformer.dart</code> is significant.<br /><br />I copy the configuration for the Polymer transformer in <code>pubspec.yaml</code>, so I also copy some of the code to parse it:<pre class="prettyprint">class ScrubJsonImports extends Transformer {<br />  List entryPoints;<br /><br />  ScrubJsonImports(this.entryPoints);<br /><br />  ScrubJsonImports.asPlugin(BarbackSettings settings)<br />    : this(_parseSettings(settings));<br /><br />  Future&lt;bool> isPrimary(Asset input) {<br />    if (entryPoints.contains(input.id.path)) return new Future.value(true);<br />    return new Future.value(false);<br />  }<br />}<br /><br />List&lt;String> _parseSettings(BarbackSettings settings) {<br />  var args = settings.configuration;<br />  return _readEntrypoints(args['entry_points']);<br />}<br /><br />List&lt;String> _readEntrypoints(value) {<br />  if (value == null) return null;<br />  return (value is List) ? value : [value];<br />}<br /></pre>Most of that pulls the <code>settings</code> from <code>pubspec.yaml</code> and creates a list of <code>entryPoints</code>—places in the application that need to be transformed—to be used as an instance variable. The <code>isPrimary()</code> method uses this list to decide if any of the assets that it sees (and will see all assets in my application) need to be transformed.<br /><br />At this point, I only need define a way for my transformer to apply its fix to Polymer's work. Given a transform with a primary input (the <code>web/index.html</code> entry point), I needs to read the input as a string, fix the string, and add the fixed string to the transform's output:<pre class="prettyprint">class ScrubJsonImports extends Transformer {<br />  // ...<br />  Future apply(Transform transform) {<br />    var input = transform.primaryInput;<br /><br />    return transform.<br />      readInputAsString(input.id).<br />      then((html){<br />        var fixed = html.replaceAllMapped(<br />          new RegExp(r'>\s*(\{[\s\S]+\})\s*&lt;polymer-element', multiLine: true),<br />          (m) => '>&lt;div style="display:none">${m[1]}&lt;/div>&lt;polymer-element'<br />        );<br /><br />        transform.addOutput(new Asset.fromString(input.id, fixed));<br />      });<br />  }<br />}</pre>To keep from double-processing assets, Pub transformers assign each a unique id attribute. This lets a transformer look up the current state of an asset and create a new state for the asset.<br /><br />The above regular expression looks through a Polymer transformer output such as:<pre class="prettyprint">...<br />  &lt;body>{<br />  "hello": "Hello",<br />  "done": "Done",<br />  "how_many": "How many?",<br />  "instructions": "Introduce yourself for an amazing personalized experience!"<br />}<br />{<br />  "hello": "Bonjour",<br />  "done": "Fin",<br />  "how_many": "Combien?",<br />  "instructions": "Présentez-vous une expérience personnalisée incroyable!"<br />}<br />{<br />  "hello": "¡Hola!",<br />  "done": "Hecho",<br />  "how_many": "¿Cuántos?",<br />  "instructions": "Preséntese para una experiencia personalizada increíble!"<br />}&lt;polymer-element name="hello-you"><br />...</pre>And will wrap the nake JSON from my <code>&lt;link></code> imports inside a hidden <code>&lt;div></code>:<pre class="prettyprint">...<br />  &lt;body><b>&lt;div style="display:none"></b>{<br />  "hello": "Hello",<br />  "done": "Done",<br />  "how_many": "How many?",<br />  "instructions": "Introduce yourself for an amazing personalized experience!"<br />}<br />{<br />  "hello": "Bonjour",<br />  "done": "Fin",<br />  "how_many": "Combien?",<br />  "instructions": "Présentez-vous une expérience personnalisée incroyable!"<br />}<br />{<br />  "hello": "¡Hola!",<br />  "done": "Hecho",<br />  "how_many": "¿Cuántos?",<br />  "instructions": "Preséntese para una experiencia personalizada increíble!"<br />}<b>&lt;/div></b>&lt;polymer-element name="hello-you"><br />...</pre>And, with that, I have my Polymer working as desired. I have imported localization JSON files into the Polymer and scrubbed Polymer's transformer resulting in a working, localized Polymer:<br /><br /><a href="http://4.bp.blogspot.com/-XjmQuvGtRKE/UsD8mKIcVyI/AAAAAAAAUtA/4FzAFlv4JrI/s1600/02-no_more_polymer_transformer_residue.png" imageanchor="1" ><img border="0" src="http://4.bp.blogspot.com/-XjmQuvGtRKE/UsD8mKIcVyI/AAAAAAAAUtA/4FzAFlv4JrI/s640/02-no_more_polymer_transformer_residue.png" /></a><br /><br />The long term solution here is to file some bug reports and work with the developers to get all of this working for everybody. Admittedly, much of tonight's effort was simply because I was curious how Dart transformers worked. Mission accomplished on that account, but it is still gratifying to have my approach to internationalization working in both JavaScript and Dart. Even if I had to muck with a simple transformer to make that happen.<br /><br /><sup><a name="fn-1">*</a></sup> This does not work in the <code>dart2js</code> compiled code—the <code>import</code> property of the <code>&lt;link></code> elements is <code>null</code>. To me the inconsistency is a bug and either the <code>import</code> property here should be the same as in the Dart VM or, better, the <code>&lt;link></code> elements should be accessible outside the <code>&lt;polymer-element></code> tag. Either way, I am not too concerned about this. I will file bugs and help get this sorted out.<br /><br /><br /><span style="color: #ccc">Day #980</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2013/12/less-fun-with-transformed-dart-polymers.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <a href="http://japhr.blogspot.com/2013/12/getting-started-with-bower-and-polymer.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script>
