---
title: 'Exploring Dart''s Async Library'
layout: post
tags:
    - dart
    - dartlang
category: seth-ladds-blog
published: '2013-02-18T21:52:00-08:00'

---

(Warning: work in progress...)<br /><br />Use Dart's async library to keep work off the main UI thread and help your users have a smooth and performant experience. The dart:async library contains classes for timers, futures, streams, and more. Effective use of dart:async keeps your apps easier to understand and your UI snappy.<br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><img border="0" src="http://1.bp.blogspot.com/-Ask4j5r7YN0/USMKsji52CI/AAAAAAAAPYQ/g1_wv2aT2Ys/s1600/5911302478_36e0840d54.jpg" style="margin-left: auto; margin-right: auto;" /></td></tr><tr><td class="tr-caption" style="text-align: center;">Telling the future is easier when you have all the data.</td></tr></tbody></table><h2><span style="font-size: large;">The event loop</span></h2><br />Or, why this all matters.<br /><br /><b>Dart programs, just like JavaScript, have no shared-state threads.</b> The UI and the program use the same thread of execution, so when the UI is updating the program isn't running. Conversely, when the programming is running, the UI isn't updating. Keeping work off of the main thread means more time for the UI to respond to user input, which means the UI feels snappy and responsive.<br /><br />The runtime maintains an event loop and a queue of work to perform. <b>The event loops pops work items off of the queue, one after another. While one work item is handled, the other work items sit in the queue patiently.</b><br /><br />Examples of work items can include callbacks for mouse move, mouse click, scroll events, database fetches, window resizes, and programatic callbacks. That is, all of the events and callbacks registered by your program or generated by the browser end up in the queue to be processed by the event loop. It's clear that <b>keeping the individual work items small is key</b> to a performant application and UI.<br /><br />(Note, in Dart you can create new isolates if you want concurrent program execution. In JavaScript, you can create new Web Workers to achieve the same effect.)<br /><br /><h2>Async programming</h2><br />As an analogy, consider these two scenarios:<br /><br />1) Send an email, stop doing any work at all until you hear a response.<br />2) Send an email, continue on your day and handle the response when you get it.<br /><br />Scenario #1 is synchronous. Scenario #2 is asynchronous.<br /><br />Here is an example of a synchronous API:<br /><br /><pre style="background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> print('at the beginning');  <br /> var file = new File('config.txt');  <br /> var contents = file.readAsStringSync(); // program blocks until all contents are read  <br /> print(contents);  <br /> print('at the end');  <br /></code></pre><br />This program will print:<br /><br /><span style="font-family: Courier New, Courier, monospace;">at the beginning</span><br /><span style="font-family: Courier New, Courier, monospace;">[config file contents]</span><br /><span style="font-family: Courier New, Courier, monospace;">at the end</span><br /><br />The above code runs as you would expect, line by line. The file contents can be used immediately in the line after readAsStringSync().<br /><br />However, if the file is large, the entire program is blocked waiting for the file to be read into memory. For simple command-line scripts this is usually acceptable, but for client-side apps or for server programs, blocking is totally not cool. Surely, we can do better!<br /><br />To write responsive and asynchronous programs, you should not block on work but instead ask to be notified when the work is complete. Here is an example of an asynchronous API:<br /><br /><pre style="background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> print('at the beginning');  <br /> var file = new File('config.txt');  <br /> Future future = file.readAsString(); // returns immediately  <br /> future.then((String contents) {  <br />  print(contents); // prints only when the file contents are ready  <br /> });  <br /> print('at the end');  <br /></code></pre><br />This program will print:<br /><br /><span style="font-family: Courier New, Courier, monospace;">at the beginning</span><br /><span style="font-family: Courier New, Courier, monospace;">at the end</span><br /><span style="font-family: Courier New, Courier, monospace;">[config file contents]</span><br /><br />On the first event loop iteration, three things happen:<br /><ol><li>print 'at the beginning'</li><li>queue up work to read the file contents</li><li>print 'at the end'</li></ol><div>When the file is completely read into memory:</div><div><ol><li>The future's callback is fired with the file contents as the value</li></ol><div>As you can see, printing the file contents happens "in the future". The program is not blocked waiting for the file to be read, as demonstrated by 'at the end' printed before the file contents.</div></div><div><br /></div><div>As an aside, you could write the code like this:</div><div><br /></div><div><pre style="background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> print('at the beginning');  <br /> var file = new File('config.txt');  <br /> file.readAsString().then((String contents) {  <br />  print(contents); // prints only when the file contents are ready  <br /> });  <br /> print('at the end');  <br /></code></pre><br />Or even more simply:<br /><br /><pre style="background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> print('at the beginning');  <br /> var file = new File('config.txt');  <br /> file.readAsString().then(print);  <br /> print('at the end');  <br /></code></pre><br />To summarize, asynchronous programming is the art of not blocking the main thread. Writing an asynchronous program can be tricky, because the program doesn't execute in what seems to be linear order. Strong abstractions and object models can help put an object-oriented interface on top of hard-to-follow asynchronous code.<br /><br /></div><h2>The dart:async library</h2><br />To help manage asynchronous programs, Dart bundles the dart:async library. Inside, you will find:<br /><br /><ul><li>Future, for handling values returned later</li><li>Completer, to help create and finish Futures</li><li>Timer, for repeating tasks, and tasks scheduled for later</li><li>Stream, for streams of events</li><li>StreamController, to help create and manage a stream</li></ul><div>Let's take a look at each of these classes.<br /><br /></div><h3>Future and Completer, aka Producing values from the future</h3><div><br />If an asynchronous method or function returns a single value (e.g. readAsString() returns one thing, the file contents), it should return a Future. A Future represents a value not yet available, with the expectation that the value will be available in the future. If a function needs to perform some work before generating a value, the function should return a Future instead of taking a callback parameter.</div><div><br /></div><div>A Completer can help manage the creation, and completion, of a future value. It is recommended to use a Completer, instead of trying to work with a raw Future.</div><div><br /></div><div>Here is an example method that uses a Completer to return and complete a Future.<br /><br /></div><pre style="background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> Future&lt;Account&gt; getAccount(String id) {  <br />  var completer = new Completer();  <br />  database.query('SELECT id FROM accounts', (results) {  <br />   var account = new Account.fromDb(results.first);  <br />   completer.complete(account);  <br />  }, (error) =&gt; completer.completeError(error));  <br />  return completer.future;  <br /> }  <br /></code></pre><div><br />(Note, the database API is fictional.)</div><div><br /></div><div>The database.query() method takes a SQL query and a callback function to handle any results. Thanks to lexical scope, the callback has access to the completer, so it can complete the future with the expected value.</div><div><br /></div><div>The second callback is run when the database driver encounters an error. Notice how you can complete a Future with an error. If you create a future, be sure to complete it with either a value or an error.</div><div><br /></div><div>The getAccount() method immediately returns the completer's future, before it queries the database. Sometime in the future, after all the network I/O and database protocol handling, the results are generated and the the completer completes.</div><div><br /></div><div>When a completer completes, the future generated by the completer gets a value, and code waiting for a value is notified.</div><div><br /></div><div>A client can use the getAccount() method like this:</div><div><br /></div><pre style="background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> Future future = getAccount('234532');  <br /> future  <br />  .then((account) =&gt; account.login())  <br />  .catchError((e) =&gt; print(e));  <br /></code></pre><div><br />Notice how catchError() is chained off of then(). This works because then() actually returns a Future.<br /><br /></div><h3>Creating futures with values that exist now</h3><div><br />Sometimes, you need to conform a synchronous API to an asynchronous API. That is, you might have a value available right now, however you need to wrap it in a Future. Luckily, there's a constructor for that.</div><div><br /></div><div>Use new Future.immediate(value) to create a future whose value is available on the next event-loop iteration. Here is an example:</div><div><br /></div><pre style="background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> Future&lt;bool&gt; isOnline() {  <br />  return new Future.immediate(true);  <br /> }  <br /></code></pre><div><br />It's rare that you have the value immediately available, especially when the API was originally designed to be asynchronous. Another use for immediate is to push the work that would be done on a value to the next event-loop cycle.</div><div><br /></div><div>Similar to Future.immediate() is Future.of(), which runs a function, collects the result, and makes it available on the next event-loop iteration. Here is an example:</div><div><br /></div><pre style="background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> bool checkConnection() {  <br />  // ...  <br /> }  <br />   <br /> Future&lt;bool&gt; isOffline() {  <br />  return new Future.of(checkConnection);  <br /> }  <br /></code></pre><div><br />The function is run now, but the value isn't made available until the next event-loop iteration.</div><div><br /></div><div>If you have a value available now, but you want to delay the completion of a Future, you can use Future.delayed(). The value is generated now, but the future waits before completing. Here is an example:</div><div><br /></div><pre style="background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> Future simulateNetworkLatency(int delayMillis) {  <br />  return new Future.delayed(delayMillis, () =&gt; makeRandomBytes());  <br /> }  <br /></code></pre><div><br />If an error occurred, and you need to immediately complete a Future with an error, you can use Future.immediateError.<br /><br /></div><pre style="background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> Future isOnline() {  <br />  if (!isConnected) {  <br />   return new Future.immediateError(new StateError('not connected'));  <br />  } else {  <br />   return new Future.immediate(true);  <br />  }  <br /> }  <br /></code></pre><br />The above code is rare, most of the time a function that returns a Future is also interacting with an asynchronous API.<br /><br />Protip: Always return a Future from a method that uses a Future. This allows the calling code to properly catch errors that might occur.<br /><br /><h3>Consuming Futures</h3><div><br />The previous section looked at producing a Future, either with a Completer or with the various constructors on Future. This section will focus on consuming Futures produced by an API.<br /><br />Tip: To learn more about the basics of consuming Futures, read <a href="http://www.dartlang.org/articles/using-future-based-apis/" target="_blank">Using Future based APIs</a> from dartlang.org.<br /><br />For robust <i>synchronous</i> code, you should expect and handle errors. Here is a typical example:<br /><br /><br /><pre style="background-color: #f0f0f0; border: 1px dashed rgb(204, 204, 204); font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; width: 450.828125px;"><code style="word-wrap: normal;"> DatabaseConnection db;  <br /> try {  <br />  db = openDatabase();  <br />  var results = db.query();  <br /> } catch (e) {  <br />  print(e);  <br /> } finally {  <br />  if (db != null) db.close();  <br /> }</code></pre><br /><br />The intended code runs inside the try block, errors and exceptions are handled inside the catch block, and the finally block is run no matter what.<br /><br />You can achieve the same type of code organization with Future-based asynchronous code. Here is an example:<br /><br /><br /><pre style="background-color: #f0f0f0; border: 1px dashed rgb(204, 204, 204); font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; width: 450.828125px;"><code style="word-wrap: normal;"> DatabaseConnection db;  <br /> Future future = openDatabase();  <br /> future  <br />  .then((_db) {  <br />   db = _db;  <br />   db.query();  <br />  })  <br />  .catchError(print)  <br />  .whenComplete(() =&gt; if (db != null) db.close()); </code></pre><br /><br />In the above example, the intended code runs inside then(), errors and exceptions are handled inside catchError(), and whenComplete() is run no matter what.<br /><br />It's very important to chain catchError() and whenComplete() from the original future object. Do not do this:<br /><br /><br /><pre style="background-color: #f0f0f0; border: 1px dashed rgb(204, 204, 204); font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; width: 450.828125px;"><code style="word-wrap: normal;"> // bad, don't do this  <br /> Future future = openDatabase();  <br /> future.then((_) =&gt; /* ... */);  <br /> // this only catches errors from openDatabase(), not from then()  <br /> future.catchError(print);  </code></pre><br /><br />The above example will not catch errors thrown by then(). You must chain then(), catchError(), and whenComplete() to full handle errors.<br /><br />You can chain Futures if you want them to run in order, one after another. Here is an example:<br /><br /><br /><pre style="background-color: #f0f0f0; border: 1px dashed rgb(204, 204, 204); font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; width: 450.828125px;"><code style="word-wrap: normal;"> db.open()  <br />  .then((_) =&gt; db.nuke())  <br />  .then((_) =&gt; db.save("world", "hello"))  <br />  .then((_) =&gt; db.save("is fun", "dart"))  <br />  .then((_) =&gt; db.getByKey("hello"))  <br />  .then((value) =&gt; query('#text').text = value)  <br />  .catchError((e) =&gt; print(e)); </code></pre><br /><br />Notice how there is one catchError() at the end of the chain. The last catchError() handles any error or exception thrown from anywhere in the chain.</div><div><br /></div><div>[Moe coming soon!]</div><div><br /></div><div><span style="font-size: xx-small;">(Photo credit:&nbsp;<a href="http://www.flickr.com/photos/49848582@N08/5911302478/">http://www.flickr.com/photos/49848582@N08/5911302478/</a>, CC)</span></div><img src="http://feeds.feedburner.com/~r/SethLaddsBlog/~4/hxMaeZSJKzY" height="1" width="1"/>
