---
title: 'Dart / JavaScript Interop Through Custom Events'
layout: post
tags: {  }
category: dartery
published: '2012-09-12T10:55:00-07:00'

---

While the Dart team works on official JS interop, there's still an immediate need for fairly simple Dart / JS integrations, like using the App Engine Channel API via its JavaScript API, as asked in <a href="http://stackoverflow.com/questions/12351225/use-appengine-channel-api-with-dart" target="_blank">this Stack Overflow question</a>.<br /><br />The solution I suggested was to proxy the Channel API via either <span style="font-family: Courier New, Courier, monospace;">window.postMessage()</span> or custom events. I've used postMessage quite a bit, but I've never actually used custom events, even though I've&nbsp;recommended&nbsp;it before. It's time I tried them out to be sure I wasn't offering up bad advice.<br /><br />It turns out that just Googling for CustomEvents in JavaScript doesn't return the most useful results, even though it's pretty straightforward, so I thought a quick post might be helpful to someone out there.&nbsp;There are really only two parts to using custom events: publishing events, and receiving events. I'll cover each in both JavaScript and Dart so that we can build bi-directional messaging.<br /><h2>CustomEvent</h2><div>First let's introduce the player that makes all of this possible: <b><span style="font-family: inherit;"><a href="http://api.dartlang.org/docs/continuous/dart_html/CustomEvent.html" target="_blank">CustomEvent</a></span></b><span style="font-family: inherit;">. All of our events will be instances of CustomEvent. CustomEvent has a few properties we care about: <b>type</b> and <b>detail</b>. type is the name of the event, and detail is the data.</span></div><div><span style="font-family: inherit;"><br /></span></div><div><span style="font-family: inherit;">detail, <a href="https://developer.mozilla.org/en-US/docs/DOM/Event/CustomEvent" target="_blank">according to MDN</a> is "</span>The data passed when initializing the event", which is vague enough for developer docs I think. In a pure JavaScript app, detail can probably be any data, but in a Dart/JS app it looks like if we restrict ourselves to JSON serializable types (String, num, bool and Lists and Maps of those), then Dart will marshall the objects into the correct types for us. Convenient!</div><div><br /></div><div>Creating a CustomEvent, like creating many objects in the DOM API, is frustratingly obscure. Whoever designed the DOM API apparently has something against constructors, because instead of the sane&nbsp;<span style="font-family: Courier New, Courier, monospace;">new CustomEvent()</span><span style="font-family: inherit;">, we must use </span><span style="font-family: Courier New, Courier, monospace;">document.createEvent('CustomEvent')</span><span style="font-family: inherit;">, which returns an instance of CustomEvent. Obvious, no? Then, just to make less sense, you have to call </span><span style="font-family: Courier New, Courier, monospace;">initCustomEvent()</span><span style="font-family: inherit;"> on the event to actually set the type and data.</span></div><div><span style="font-family: inherit;"><br /></span></div><div><span style="font-family: inherit;">Dart has been fixing up the DOM some in dart:html, notably adding constructors for subclasses of HTMLElement, so I filed <a href="http://code.google.com/p/dart/issues/detail?id=5097" target="_blank">a bug to add a constructor for CustomEvent</a>. Star at will.</span></div><h2>Listening to CustomEvents</h2><div>The easier half of CustomEvents, in my opinion, is listening to events.</div><div><br /></div><div>In Dart it's quite simple, if we want to listen to an event of type 'foo' on window, we can use the [] operator of WindowEvents (or any Events subclass, like ElementEvents). This allows us to access events that are not predefined like window.on.load is by using a String event type.</div><div><br /></div><div class="syntax"><pre>window.on['foo'].add((e) =&gt; print(e.detail));<br /></pre></div><div class="p1"><br /></div><div class="p1">To do the same thing in JavaScript we use window.addEventListener, like so:</div><div class="p1"><br /></div><div class="syntax"><pre>window.addEventListener('foo', function(e) {<br />  console.log(e.detail);<br />});</pre></div><h2>Publishing CustomEvents</h2><div class="p1">Publishing a CustomEvent requires three steps: create the event, using the aforementioned createEvent() method; set the event's type and detail properties; and finally, dispatch the event on the proper object. In both Dart and JavaScript I prefer to bundle these steps into a publishEvent() function. Note here I'm always sending events on the window object. You could easily make source a parameter to publish on different objects, such as Elements.</div><div class="p1"><br /></div><div class="p1">Dart:</div><div class="p1"><br /></div><div class="p1"></div><div class="syntax"><pre>void sendEvent(String type, String detail) {<br />  var event = document.$dom_createEvent('CustomEvent');<br />    ..initCustomEvent(type, false, false, detail);<br />  window.on[type].dispatch(event);<br />}<br /></pre></div><div class="p1"><br />JavaScript:</div><div class="p1"><br /></div><div class="p1"></div><div class="syntax"><pre>function _send(type, detail) {<br />  var event = document.createEvent('CustomEvent');<br />  event.initCustomEvent(type, false, false, detail);<br />  window.dispatchEvent(event);<br />}<br /></pre></div><div class="p1"><br />And that's pretty much it. Typically for JS interop you'll subscribe to a particular event type from one side of the Dart/JS divide and publish from the other. Complicated interactions will require multiple event types and/or complex payloads. I'll cover using App Engine's Channel API from Dart in a follow-up post to illustrate this.</div><div class="p1"><br /></div><div class="p1">Dart on, Dartisians!</div><div class="p1"><br /></div><br /><br />
