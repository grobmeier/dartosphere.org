---
title: 'Solving Boggle with Dart'
layout: post
tags:
    - dart
    - dartlang
category: seth-ladds-blog
published: '2013-03-19T09:00:00-07:00'

---

My friends at work and I have been playing a lot of Scramble with Friends. It's a "tile based word searching game" where you find words on a 4x4 grid of letters. Being a good Dart hacker, I wanted to try writing a small library to find all possible words on the board. Here's how I did it!<br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><img border="0" src="http://3.bp.blogspot.com/-NgEX7-t-63E/UUf_0JAbSiI/AAAAAAAAVWM/zNF3HZWDdgA/s1600/Screen+Shot+2013-03-18+at+11.04.27+PM.png" style="margin-left: auto; margin-right: auto;" /></td></tr><tr><td class="tr-caption" style="text-align: center;">Dart, not trad. :)</td></tr></tbody></table>First off, props to <a href="http://danvk.org/">danvk.org</a> and his helpful posts (such as this <a href="http://www.danvk.org/wp/2007-02-01/tries-the-perfect-data-structure/" target="_blank">one</a>) on solving Boggle.<br /><br /><span style="font-size: large;">Old 'n busted</span><br /><br />My first attend was the naive version. The following code simply tried every possible combination, in a depth-first search. It works, but it's slow. So very slow.<br /><br /><br /><pre style="background-color: #f0f0f0; border: 1px dashed rgb(204, 204, 204); font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; width: 450.828125px;"><code style="word-wrap: normal;">class Solver {  <br />  final Map _words;  <br />  final List&lt;List&lt;String&gt;&gt; _grid;  <br />  final List&lt;List&gt; _visited = new List.generate(4, (_) =&gt; new List.filled(4, false));  <br />  final List _found = new List();  <br />    <br />  Solver(this._words, this._grid);  <br />    <br />  _solve(int x, int y, [String word = '']) {  <br />   _visited[x][y] = true;  <br />     <br />   final newWord = '${word}${_grid[x][y]}';  <br />     <br />   if (_words.containsKey(newWord)) {  <br />    _found.add(newWord);  <br />   }  <br />     <br />   for (var _x = -1; _x &lt; 2; _x++) {  <br />    final nX = x + _x;  <br />    if (nX &lt; 0 || nX &gt; 3) continue;  <br />    for (var _y = -1; _y &lt; 2; _y++) {  <br />     if (_x == 0 &amp;&amp; _y == 0) continue;  <br />     final nY = y + _y;  <br />     if (nY &lt; 0 || nY &gt; 3) continue;  <br />     if (_visited[nX][nY] == true) continue;  <br />     _solve(nX, nY, newWord);  <br />    }  <br />   }  <br />     <br />   _visited[x][y] = false;  <br />  }  <br />    <br />  Iterable&lt;String&gt; findAll() {  <br />   for (var x = 0; x &lt; 4; x++) {  <br />    for (var y = 0; y &lt; 4; y++) {  <br />     _solve(x, y);  <br />    }  <br />   }  <br />     <br />   return _found;  <br />  }  <br /> }  </code></pre><br /><br />Some notes for the code above:<br /><br /><ul><li>Real classes!</li><li>Use _ to mark names as private to the library.</li><li>Final variables can't be reassigned after they are initialized. This leads to safer code.</li><li>The third parameter to _solve is an "optional positional parameter". It has a default value of an empty string.</li></ul><br />Full recursion across all possible combinations?!? Surely we can do better!<br /><br /><span style="font-size: large;">New hotness</span><br /><br />Enter a data structure called a <a href="http://en.wikipedia.org/wiki/Trie" target="_blank">Trie</a>. A trie is an efficient data structure for dictionaries, because the nodes in the tree are letters that spell words.<br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><img border="0" src="http://4.bp.blogspot.com/-Xx70UJTNO5M/UUgAeRhV2-I/AAAAAAAAVWU/Whf0e65Jo9o/s1600/500px-Trie_example.png" style="margin-left: auto; margin-right: auto;" /></td></tr><tr><td class="tr-caption" style="text-align: center;">From&nbsp;<a href="http://en.wikipedia.org/wiki/File:Trie_example.svg">http://en.wikipedia.org/wiki/File:Trie_example.svg</a></td></tr></tbody></table>Here is the code I used for the Trie. Thanks to <a href="https://plus.google.com/110742501143171151210/posts" target="_blank">Ladislav Thon</a> for the <a href="https://github.com/Ladicek/dart-trie" target="_blank">initial inspiration</a>.<br /><br /><br /><pre style="background-color: #f0f0f0; border: 1px dashed rgb(204, 204, 204); font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; width: 450.828125px;"><code style="word-wrap: normal;">library trie;  <br />   <br /> import 'dart:collection';  <br />   <br /> class Trie&lt;T&gt; {  <br />  T value;  <br />  final Map&lt;int, Trie&lt;T&gt;&gt; map;  <br />   <br />  Trie() : map = new Map&lt;int, Trie&lt;T&gt;&gt;();  <br />   <br />  T operator [](String key) {  <br />   var node = this;  <br />   for (int i = 0; i &lt; key.length; i++) {  <br />    int char = key.codeUnitAt(i);  <br />   <br />    node = node.map[char];  <br />    if (node == null) {  <br />     return null;  <br />    }  <br />   }  <br />   return node.value;  <br />  }  <br />    <br />  Trie&lt;T&gt; nodeFor(String character) {  <br />   return map[character.codeUnitAt(0)];  <br />  }  <br />   <br />  void operator []=(String key, T value) {  <br />   var node = this;  <br />   for (int i = 0; i &lt; key.length; i++) {  <br />    int char = key.codeUnitAt(i);  <br />   <br />    var current = node;  <br />    node = node.map[char];  <br />    if (node == null) {  <br />     current.map[char] = node = new Trie&lt;T&gt;();  <br />    }  <br />   }  <br />   node.value = value;  <br />  }  <br /> }  </code></pre><br /><br />A couple notes about the code above:<br /><br /><ul><li>A trie is a tree of strings to values, so I use Dart's generics (aka parameterized types) to clearly annotate that a Trie can hold a specific kind of value <i>T</i>&nbsp;(to be specified by the consumer of this trie).</li><li>Dart classes can define [], the index access operator.</li><li>Dart supports libraries, so I placed this code into its own library.</li></ul><div>Here is the new Solver, that uses the Trie:</div><div><br /></div><div><pre style="background-color: #f0f0f0; border: 1px dashed rgb(204, 204, 204); font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; width: 450.828125px;"><code style="word-wrap: normal;"> library solver;  <br />   <br /> import 'dart:math';  <br /> import 'package:tilebasedwordsearch/trie.dart';  <br /> export 'package:tilebasedwordsearch/trie.dart' show Trie;  <br />   <br /> class Solver {  <br />  final Trie _words;  <br />  final List&lt;List&lt;String&gt;&gt; _grid;  <br />  final List&lt;List&gt; _visited = new List.generate(4, (_) =&gt; new List.filled(4, false));  <br />  final List _found = new List();  <br />    <br />  Solver(this._words, this._grid);  <br />    <br />  _solve(int x, int y, Trie inProgress) {  <br />     <br />   final Trie nextStep = inProgress.nodeFor(_grid[x][y]);  <br />     <br />   if (nextStep != null) {  <br />    if (nextStep.value != null) {  <br />     // FIXME: add real word  <br />     _found.add(nextStep.value);  <br />    }  <br />   <br />    _visited[x][y] = true;  <br />      <br />    for (var _x = -1; _x &lt; 2; _x++) {  <br />     final nX = x + _x;  <br />     if (nX &lt; 0 || nX &gt; 3) continue;  <br />     for (var _y = -1; _y &lt; 2; _y++) {  <br />      if (_x == 0 &amp;&amp; _y == 0) continue;  <br />      final nY = y + _y;  <br />      if (nY &lt; 0 || nY &gt; 3) continue;  <br />      if (_visited[nX][nY] == true) continue;  <br />      _solve(nX, nY, nextStep);  <br />     }  <br />    }  <br />   <br />    _visited[x][y] = false;  <br />   }  <br />     <br />  }  <br />    <br />  Iterable&lt;String&gt; findAll() {  <br />   for (var x = 0; x &lt; 4; x++) {  <br />    for (var y = 0; y &lt; 4; y++) {  <br />     _solve(x, y, _words);  <br />    }  <br />   }  <br />     <br />   return _found;  <br />  }  <br /> }  </code></pre></div><br /><br />The real interesting part to me is that the Trie can act as the dictionary as well as the "in progress" tracking. As the solver walks through the tiles on the board, it looks to see if the current node in the tree has a child node for the adjacent tile. If not, the solver simply bails out immediately. No more searching all possible combinations! The new implementation above also does not build the potential word by concatenating strings, character by character. Instead, it just walks the tree until it it finds a word (the word is stored as a value on the left node) or a dead-end.<br /><br /><span style="font-size: large;">In action</span><br /><br />Here's how I use it in a very simple web app. I was mostly concerned about benchmarks, so there's no UI.<br /><br /><br /><pre style="background-color: #f0f0f0; border: 1px dashed rgb(204, 204, 204); font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; width: 450.828125px;"><code style="word-wrap: normal;"> import 'dart:html';  <br /> import 'package:tilebasedwordsearch/solver.dart';  <br />   <br /> main() {  <br />  var timeToParseFiles = query("#time-to-parse-file");  <br />  var numWords = query('#num-words');  <br />  var resultsWords = query('#results-words');  <br />  var resultsLength = query('#results-length');  <br />  var time = query('#time');  <br />    <br />  const List&lt;List&lt;String&gt;&gt; grid = const [  <br />   const ['A', 'B', 'C', 'D'],  <br />   const ['E', 'F', 'G', 'H'],  <br />   const ['I', 'J', 'K', 'L'],  <br />   const ['M', 'N', 'O', 'P']  <br />  ];<br />    <br />  Trie words = new Trie();  <br />    <br />  HttpRequest.getString("../assets/dictionary.txt")  <br />   .then((contents) {  <br />    var start = window.performance.now();  <br />    contents.split("\n").forEach((line) =&gt; words[line] = line);  <br />    var stop = window.performance.now();<br />    var readFilesTime = stop - start; <br />      <br />    var solver = new Solver(words, grid);  <br />      <br />    start = window.performance.now();  <br />    List&lt;String&gt; results = solver.findAll().toList();  <br />    stop = window.performance.now();<br />    var findAllTime = stop - start;  <br />      <br />    timeToParseFiles.text = '$readFilesTime';  <br />    resultsWords.text = '$results';  <br />    resultsLength.text = '${results.length}';  <br />    time.text = 'Found in $findAllTime ms';  <br />   })  <br />   .catchError((e) =&gt; print(e));  <br /> }  </code></pre><br /><br />The above Solver and Trie runs in about 1ms on my local machine (finding 33 words in the test board, using my dictionary), which is good enough for me. This is very much a fun weekend project, not meant to be production code. Hopefully it helps you learn a bit of Dart!<img src="http://feeds.feedburner.com/~r/SethLaddsBlog/~4/qpEEMxOI1ao" height="1" width="1"/>
