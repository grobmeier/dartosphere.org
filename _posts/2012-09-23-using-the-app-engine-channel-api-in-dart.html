---
title: 'Using the App Engine Channel API in Dart'
layout: post
tags: {  }
category: dartery
published: '2012-09-23T17:22:00-07:00'

---

In <a href="http://dartery.blogspot.com/2012/09/dart-javascript-interop-through-custom.html" target="_blank">this post</a>, I showed how to do a limited form of JS interop via custom events. This technique really only works well for&nbsp;asynchronous&nbsp;APIs, and is too tedious for large APIs, but it's quite reasonable for APIs that are event based because all you're doing is forwarding events across the JS/Dart divide.<br /><br />One such API that's been brought up in <a href="https://groups.google.com/a/dartlang.org/d/topic/misc/SVnAy3CzHpY/discussion" target="_blank">misc@dartlang.org posts</a> and <a href="http://stackoverflow.com/questions/12351225/use-appengine-channel-api-with-dart" target="_blank">Stack Overflow questions</a> is the Google App Engine <a href="https://developers.google.com/appengine/docs/java/channel/" target="_blank">Channel API</a>.<br /><br />For those who don't know, the Channel API is server-push for App Engine. The really nice thing is that it allows App Engine apps to send messages to browsers without having to know how it's done. It might use polling or hanging GETs or WebSockets... we don't know, or have to. &nbsp;All you have to know is how to use the Channel API to register a client and send it a message.<br /><br />This is nice, but it presents a problem for porting to Dart. We can't just port the JavaScript, because the App Engine servers might send different versions of the JavaScript depending on what APIs the browsers and servers support. Instead we have to use the custom event technique to proxy the provided JavaScript API.<br /><br />I just pushed such a Dart version of the Channel API that uses custom events to Google Code.<br /><br /><a href="http://code.google.com/p/gwt-gae-channel/">http://code.google.com/p/gwt-gae-channel/</a><br /><br />Using it is fairly straightforward, here's an example that registers handler's to print all messages:<br /><pre class="syntax">openChannel(String token) {<br />  Channel channel = new Channel(token);<br />  Socket socket = channel.open()<br />    ..onOpen = (() =&gt; print("open"))<br />    ..onClose = (() =&gt; print("close"))<br />    ..onMessage = ((m) =&gt; print("message: $m"))<br />    ..onError = ((code, desc) =&gt; print("error: $code $desc"));<br />}<br /></pre>To port to Dart I created Dart versions of Channel and Socket, very much like the <a href="http://code.google.com/p/gwt-gae-channel/" target="_blank">GWT port</a>, but they work very differently, since Dart doesn't have JSNI or overlay types like GWT.<br /><br />In Dart the classes forward their method calls as custom events that are received in JavaScript handlers, and they listen for custom events that are fired when the Channel API calls our handlers on the JavaScript side.<br /><br />When a channel is opened the JavaScript handler creates a channel, opens it to get a socket and adds handlers to the socket that forward events back to Dart through custom events. It keeps track of sockets in a map keyed by token so that they can be later closed. The Dart side also keeps tracks of Sockets in a Map keyed by token so that it can associate messages received via custom event to the correct Socket instance. Thus, the tokens function as a Socket ids.<br /><br />This pattern of having maps of id-&gt;instance on both sides of the JS/Dart divide is going to be common for this type of interop. The instances are proxys, and the ids help route messages to the right instance. The Channel API is small and naturally lends itself to this pattern especially using tokens as ids. For other APIs it might be necessary to generate synthetic unique ids for this purpose.<br /><br />If you're combining Dart and App Engine, and can make use of this library, please try it out and let me know if it's working for you. It probably needs more testing and of course, contributions are always welcome!<br /><br />
