---
title: 'Polymer Plunge'
layout: post
tags:
    - Dart
    - Polymer
category: null
published: '2013-10-09T18:08:49+00:00'

---

<p>Well it&#8217;s about time that I took theÂ Polymer Plunge. I have a project in the office that is constantly growing, frequently getting new feature or component requests. This was totally anticipated from the beginning however. As such from the get-go I decided to go with Web Components and web_ui to build the application. It made each component much more modular and easy to assemble. I&#8217;ll get more into why web_ui / dart in a different post.</p>
<p>But the days of web_ui are waning. Polymer is the new shining light and as its feature set starts to match web_ui the time has come for me to start migrating over to Polymer.dart. But where to start? The documentation for Polymer is still pretty sparse, and the quick pace that Polymer is evolving, the few existing blog posts and articles are becoming out-dated quickly. <a title="Seth Ladd" href="https://plus.google.com/+SethLadd">+Seth Ladd</a> has started a (somewhat redundantly named) GitHub Repo: <a title="Polymer.dart Samples and Examples" href="https://github.com/sethladd/dart-polymer-dart-examples">dart-polymer-dart-examples</a> which is essentially the current de facto repository of simple Polymer examples. So I&#8217;ll start there. [Edit: Recently the documentation situation has improved significantly and a great platform for getting documentation is the dartlang.org's <a title="Polymer.dart" href="https://www.dartlang.org/polymer-dart/" target="_blank">Polymer.dart</a> page. Also see the <a href="https://www.dartlang.org/docs/tutorials/polymer-intro/" title="Polymer Intro">Polymer Intro Tutorial</a>.]</p>
<p>First stop is the <a title="README.md" href="https://github.com/sethladd/dart-polymer-dart-examples/blob/master/README.md">README</a> file, as all of his notes on how to use Polymer and various quirks are stored in there. I&#8217;ll note some other issues I ran into porting over my web_ui application below. The README is fairly up-to-date and contains many of the latest and greatest changes that have occurred with the Dart Polymer port. After reading that through, be sure to go through many of the samples found in that repository&#8217;s <a title="dart-polymer-dart-examples/web" href="https://github.com/sethladd/dart-polymer-dart-examples/tree/master/web" target="_blank">web directory</a>. There is no real order set to them, but it&#8217;s great for a quick and dirty cookbook type usage. Find the example you want to learn about and look at that code. One caveat I will mention is that if you&#8217;re looking for a CustomEvent example, look at the <a title="todo_element" href="https://github.com/sethladd/dart-polymer-dart-examples/tree/master/web/todo_element" target="_blank">todo_element</a> sample.</p>
<p>Additionally, I spent a fair bit of time looking at the <a href="https://code.google.com/p/dart/source/browse/#svn%2Fbranches%2Fbleeding_edge%2Fdart%2Fpkg%2Fpolymer%2Ftest" title="Polymer Ters" target="_blank">tests for Polymer</a> from the package&#8217;s repository to get a good feel for how things are expected to behave.</p>
<p>Now for some of the issues I ran into during my porting process:</p>
<dl>
<dt>Use <code>&lt;polymer-element&gt;</code> and not <code>&lt;element&gt;</code></dt>
<dd>First and foremost I&#8217;ll get this simple one out of the way. When declaring a custom element in Polymer, use the <code>&lt;polymer-element&gt;</code> tag to define your element, not the old <code>&lt;element&gt;</code> tags.</dd>
<dt>dart:json is depreciated</dt>
<dd>dart:json is going away. I needed to take a little time to convert everything over to use dart:convert. Fortunately it involved very little changes, as I always prefixed my dart:json import anyways. Code changed from <code>Json.stringify(...)</code> over to be <code>JSON.encode(...)</code> and from <code>Json.parse(...)</code> to be <code>JSON.decode(...)</code>.</dd>
<dt>Can&#8217;t just call <code>query()</code></dt>
<dd>Because web_ui was never really integrated with the <a title="ShadowDom 101" href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/" target="_blank">ShadowDom</a>, it was possible to just call <code>query()</code> within an element&#8217;s class and you could get the nodes from within that element. Now if you want to properly access those components you have to call <code>shadowRoot.query()</code>. shadowRoot will return the ShadowDom for this element, and is the same as calling <code>getShadowRoot('my-tag')</code>. You will sometimes see the latter in sample code as early on there were some issues with <code>shadowRoot</code> returning null when it shouldn&#8217;t be. These have since been resolved.</dd>
<dt><code>ObservableMixin</code> is already included</dt>
<dd>Sticking with some legacy Polymer stuff, many Polymer samples will show that you need to define the element&#8217;s class as <code>class MyElement extends PolymerElement with ObservableMixin</code>. Fortunately, because it was such a common situation, <code>ObservableMixin</code> is automatically included for us now. We no longer need to add the <code>with ObservableMixin</code> portion every time.</dd>
<dt><code>@CustomTag()</code> Annotation replaces constructor attribute</dt>
<dd>In web_ui if we had a class with the <a title="UpperCamelCase" href="http://en.wikipedia.org/wiki/UpperCamelCase">UpperCamelCase</a> name of our custom element, it would automatically perform the association of element to class for us. If we wanted to specify a different class to use for the custom element, we could pass the constructor attribute specifying what class to use for the element&#8217;s model. That functionality doesn&#8217;t exist with Polymer, and instead we must use the <code>@CustomTag()</code> annotation and pass in a string which matches the value passed to the name attribute of our Polymer Element. In the long run this makes it much easier to choose our associated classes and identify them in the code without the need to flip back and forth to the HTML file if we decide on a classname change later.</dd>
<dt>No dash-to-camelCase Mapping</dt>
<dd>One feature of web_ui that I admit I miss is the automatic mapping of dashed attribute-names to camelCase attributeNames. For instance if I had <code>my-value</code> in web_ui it would automatically map it to <code>myValue</code> in the dart code. That functionality has been removed to keep similar behaviour with the JavaScript version of Polymer. The current recommended method is to use camelCase or lowercase attribute names in the HTML and camelCase in the dart code (HTML is case insensitive so Polymer is maintaining that).</dd>
<dt>Make your entire app a tag</dt>
<dd>In Polymer the suggested style is to make the entire app a tag. Essentially your index page would look something like: <code>...&lt;body&gt;&lt;my-app&gt;&lt;/my-app&gt;&lt;/body&gt;</code>. In part this is because in Polymer, everything is a tag. However this is actually important as well because unlike web_ui, you cannot bind variables (single or two-way) which are not within template tags. Additionally, you can&#8217;t bind global variables, and rather bind variables from the associate model directly.</dd>
<dt>Bind to <code>value=</code> and not with <code>bind-value</code></dt>
<dd>In web_ui if we wanted to do two-way binding, we would use <code>bind-value</code> or maybe <code>bind-value-as-number</code> or something like that. Fortunately that&#8217;s been simplified in Polymer. Now we bind directly as you would do for one-way binding, but we pass it as the <code>value=</code> for the input element. That is now we would write: <code>&lt;input type="text" value="{{myValue}}"&gt;</code> instead of using <code>&lt;input type="text" bind-value="myValue"&gt;</code>. Note that the addition of the moustache braces {{ }}} is required.</dd>
<dt>Need to manually bind observable getters</dt>
<dd>It used to be very simple to implement observable getters in web_ui. As long as you added the <code>@observable</code> annotation to the getter, and as long as one of the backing properties it used was observable, then you had an easy observable getter. In Polymer it&#8217;s a bit more involved. In order to setup an observable getter we need to setup an onPropertyChange binding for our backing observable, and then from the callback that takes, we need to call notifyProperty on the getter. (Note: on the plus side, now that we have support for Symbol literals, with the # sign, this becomes much shorter) <code>onPropertyChange(this, #backingObservable, () => notifyProperty(this, #obserableGetter));</code> where <code>#backObserable</code> is the name of the observable that&#8217;s used, and <code>#observableGetter</code> is the name of the getter that we want to be observable.<br />
Apparently, I&#8217;m just learning, if you have a variable named <code>foo</code> and setup a method named <code>fooChanged(var oldValue)</code> (or accepts whatever type of <code>foo</code> is) then it will automatically create the <code>onPropertyChange</code> stuff for you and instead just execute whatever is in your method. So my above code could be: <code>backObservableChange(var oldValue) => notifyProperty(this, #observableGetter);</code> That&#8217;ll help keep things even that much cleaner for you. And no worries about <a href="http://stackoverflow.com/questions/19188574/where-to-bind-observable-getters-in-polymer" title="where to bind observable getters" target="_blank">where to put the property bindings</a>.</dd>
<dt>Public variables are not automatically attributes</dt>
<dd>In web_ui anytime I wanted to make an attribute on the Custom Element&#8217;s HTML tag, I just had to make sure the value was a public property in the corresponding class. Polymer is a little more secretive. Initially polymer required an <code>attributes</code> tag to manually specify which properties were to be settable attributes from the tag. Unfortunately this made for a lot of back and forth while changing or adding variables, putting it in the attributes tag and then in the corresponding dart class. However that was all changed with addition of the <code>@published</code> annotation. Now any variable that is flagged with the <code>@published</code> annotation automatically becomes observable and it is accessible as an attribute on your custom element&#8217;s tag.</dd>
<dt>Can&#8217;t pass arguments to event callbacks</dt>
<dd>A common pattern for me in web_ui was to pass arguments to my callbacks, such as: <code>.. on-click="handleClick($event)"</code> or sometimes I&#8217;d pass a string as the argument. All of that is no more though. With event callbacks in polymer, you cannot provide a full method to call, rather you only provide the name of the method. That method is then called automatically with 3 arguments. So your event binding still looks pretty similar, but you&#8217;re dropping the parens <code>.. on-click="handleClick"</code>. You&#8217;re method should then have a signature like this: <code>void handleClick(Event e, var details, Node node) {...</code>. We automagically receive the Event and even the node that triggered the event.
<dd>
<dt>Binding to <code>disabled</code> attribute</dt>
<dd>Another surprise I ran into with binding to attributes, was with the <code>disabled</code> property. With web_ui I could bind a boolean value to disabled with something like: <code>.. disabled="{{isDisabled}}"</code>. However if I do that in Polymer, the element is disabled regardless of if <code>isDisabled</code> is true or not. Instead the solution was to use a type of conditional assignment I had not realized existed: <code>.. disabled?="{{isDisabled}}"</code>. Now when <code>isDisabled</code> is false, then the element is active and working.</dd>
</dl>
<p>I&#8217;m still in the process of migrating my code-base over to Polymer. However in most cases I&#8217;ve found it to be an almost direct copy/paste process. There have been a few changes such as adding the <code>@published</code> annotation, or a few other minor changes as I move from a callback system to a proper custom events system. Most of the changes I&#8217;ve needed to make were in the HTML declarative syntax for the Polymer Elements. Most of my dart classes remained virtually the same.</p>
<p>In general, Polymer has made creating and working with HTML fun again. To so simply declare my own elements and reuse them again and again, and to consistently achieve the same results&#8230; This is what I&#8217;ve been looking and waiting for since I was 14!</p>
<p>See my follow up post: <a href="http://blog.butlermatt.me/?p=35" title="Polymer Plunge: Diving In">Polymer Plunge: Diving In</a> for a few more caveats of note.</p>

