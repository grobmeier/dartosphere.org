---
title: 'Day 995: Observing Model Attributes in Polymer'
layout: post
tags:
    - chain
    - dart
    - dartlang
    - polymer
category: japhr-by-chris-strom
published: '2014-01-13T23:59:00-05:00'

---

<div class=top-chain-links></div><br />As of last night, I have a nifty little pizza builder <a href="http://www.polymer-project.org/">Polymer</a>:<br /><br /><a href="http://3.bp.blogspot.com/-dXWr85bxmhs/UtSntk29vfI/AAAAAAAAU0o/l1epJyhuEzE/s1600/01-pizza_model.png" imageanchor="1" ><img border="0" src="http://3.bp.blogspot.com/-dXWr85bxmhs/UtSntk29vfI/AAAAAAAAU0o/l1epJyhuEzE/s640/01-pizza_model.png" /></a><br /><br />OK, so maybe not <i>that</i> nifty, but it was pretty easy to slap together. It is also fairly well-factored, slapped-together code, by virtue of a separate model that describes the internal state of the pizza. There is still room for improvement, however, as I would like for the model to be able to signal to the Polymer (or anything else for that matter) that its internal state has changed.<br /><br />Currently, when the user adds an ingredient to the pizza, each of the various add-ingredient methods need to tell the main UI element to re-draw itself:<pre class="prettyprint">@CustomTag('x-pizza')<br />class XPizza extends PolymerElement {<br />  // ...<br />  addFirstHalf() {<br />    model.firstHalfToppings.add(currentFirstHalf);<br /><b>    pizzaState = model.toString();</b><br />  }<br />  // ...<br />}<br /></pre>That's not horrible except each one of the add-ingredient methods needs to update the value of <code>pizzaState</code> in exactly the same way so that it is available in the template:<pre class=prettyprint>&lt;polymer-element name="x-pizza"><br />  &lt;template><br />    &lt;h2>Build Your Pizza&lt;/h2><br />    &lt;pre><b>{{pizzaState}}</b>&lt;/pre><br />    &lt;!-- ... --><br />  &lt;/template><br />  &lt;script type="application/dart" src="x_pizza.dart">&lt;/script><br />&lt;/polymer-element></pre>But there must be a better way to communicate that information, right?<br /><br />The approach that I take is making the various properties in the <code>Pizza</code> class <code>@observable</code>:<pre class="prettyprint">class Pizza {<br />  @observable List&lt;String> firstHalfToppings = toObservable([]);<br />  // ...<br />}</pre>Back in the main Polymer element, I mark the <code>Pizza</code> model as <code>@observable</code> as well:<pre class=prettyprint>@CustomTag('x-pizza')<br />class XPizza extends PolymerElement {<br />  <b>@published Pizza model;</b><br />  // ...<br /><b>  addFirstHalf() {<br />    model.firstHalfToppings.add(currentFirstHalf);<br />  }</b><br />  // ...<br />}</pre>I also remove the duplicated pizzaState setting.<br /><br />To get this to work, I have to listen to the model's attribute:<pre class=prettyprint>@CustomTag('x-pizza')<br />class XPizza extends PolymerElement {<br />  // ...<br />  @published Pizza model;<br />  XPizza.created(): super.created() {<br /><b>    model.firstHalfToppings.changes.listen((records) {<br />      pizzaState = model.toString();<br />      print('changed: $records');<br />      print(model.toString());<br />    });</b><br />  }<br />  // ...<br />}</pre>Listening to the model itself is not sufficient as it does not see changes from its own properties. <br /><br />Interestingly, or should I say frustratingly, I cannot bind template variables to the model's properties:<pre class="prettyprint">&lt;polymer-element name="x-pizza"><br />  &lt;template><br />    &lt;h2>Build Your Pizza&lt;/h2><br />    &lt;pre><br /><b>{{model.firstHalfToppings}}<br />{{model.secondHalfToppings}}</b>&lt;/pre><br />  &lt;/template><br />  &lt;script type="application/dart" src="x_pizza.dart">&lt;/script><br />&lt;/polymer-element></pre>They show the initial value of an empty list, but never update. What is especially frustrating is that, if I include <code>pizzaState</code> in addition to those bound model attributes, then it works:<pre class="prettyprint">&lt;polymer-element name="x-pizza"><br />  &lt;template><br />    &lt;h2>Build Your Pizza&lt;/h2><br />    &lt;pre><br /><b>{{pizzaState}}</b><br />{{model.firstHalfToppings}}<br />{{model.secondHalfToppings}}&lt;/pre><br />  &lt;/template><br />  &lt;script type="application/dart" src="x_pizza.dart">&lt;/script><br />&lt;/polymer-element></pre>The simple inclusion of that Polymer attribute results in both it being updated as well as the model attributes:<br /><br /><a href="http://3.bp.blogspot.com/-J3CAQT2YVxI/UtTGaWznvLI/AAAAAAAAU04/CLF1N4xvDSY/s1600/02-only_observes_when_core_attr.png" imageanchor="1" ><img border="0" src="http://3.bp.blogspot.com/-J3CAQT2YVxI/UtTGaWznvLI/AAAAAAAAU04/CLF1N4xvDSY/s640/02-only_observes_when_core_attr.png" /></a><br /><br />And I am not sure why. I think it may be time to take a break to get more familiar with model driven views in JavaScript tomorrow. After that, hopefully, I will have a better idea how to do this in Dart.<br /><br /><br /><span style="color: #ccc">Day #995</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/01/day-994-stay-classy-with-polymer-models.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <a href="http://japhr.blogspot.com/2014/01/day-997-model-driven-views-in-polymer-js.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script>
