---
title: 'Memoizing Functions in Dart'
layout: post
tags: {  }
category: dartery
published: '2012-09-22T20:08:00-07:00'

---

Today I saw a <a href="http://www.reddit.com/r/programming/comments/109599/dynamic_programming_bayesian_blocks_adaptive/" target="_blank">post on Reddit</a>&nbsp;about&nbsp;dynamic programming&nbsp;that reminded me of <a href="http://en.wikipedia.org/wiki/Memoization" target="_blank">memoization</a>, so I thought I'd try some experiments in Dart to see how it handles some of the more interesting techniques I've seen in other languages.<br /><br /><a href="http://en.wikipedia.org/wiki/Dynamic_programming" target="_blank">Dynamic programming</a> and memoization are concepts that are so useful that I remember being excited when I learned them, but actually disappointed that I hadn't learned them earlier. If you're not&nbsp;familiar&nbsp;with them, I highly&nbsp;recommend&nbsp;reading up.<br /><br />To very quickly summarize: memoization is the strategy of caching the results of function invocations and using the cache when possible on subsequent invocations instead of re-calculating the result. This can obviously speed up repeated function calls with the same arguments. Where things become awesomer is when dealing with recursive functions that call themselves multiple times with the same argument as they recurse. Naive implementations of such functions do a lot of repeated work and can run very slowly, and dynamic programming can dramatically speed them up.<br /><h2>Example: Fibbonaci</h2>The most common example is a function to calculate Fibbonaci numbers. The naive implementation looks like this:<br /><pre class="syntax" style="font-family: Courier New, Courier, monospace;">int fib(int n) =&gt; (n &lt; 2) ? n : fib(n - 1) + fib(n - 2);</pre>This is pretty much a straight translation of the recursive relation definition of a Fibbonaci number. What's nice about this is that it's simple, it's a very common example of a recursive function, and was even the default example on the Dartboard for a while. The problem is that it's <b>slow</b>. So slow that I hate ever seeing the naive version shown, even as an example, when a much faster version is still simple.<br /><br />Here's a version that uses dynamic programming:<br /><pre class="syntax" style="font-family: Courier New, Courier, monospace;">int dynamicfib(int n) {<br />  var r = new List&lt;int&gt;(n + 1);<br />  r[0] = 0;<br />  r[1] = 1;<br />  for (int i = 2; i &lt; n + 1; i++) {<br />    r[i] = r[i - 1] + r[i - 2];<br />  }<br />  return[n];<br />}<br /></pre>It runs&nbsp;<b>significantly</b>&nbsp;faster. How much faster? In cases where the recursive version would still be running at the heat death of the universe, the non-recursive can give an answer while you wait. <span style="font-family: Courier New, Courier, monospace;">fib(40)</span> takes <i>41 seconds</i> to compute recursively on my laptop,&nbsp;<span style="font-family: Courier New, Courier, monospace;">dynamicfib</span>&nbsp;takes&nbsp;<i>less than a millisecond. </i>Whoa.<br /><h2>Automatic Memoization</h2><blockquote class="tr_bq"><i>"Memoization isn't cool. You know what's cool? Automatic memoization." - No One Ever</i></blockquote>So our memoized Fibonacci function is about a zillion times faster than the recursive one. But it's not as&nbsp;obviously&nbsp;correct when compared to the recursive relation definition of a Fibbonaci number.<br /><br />If we could take the simple recursive definition and run it through a process where it just remembers previous values, then we would have a fast <i>and</i> easy to inspect implementation.<br /><br />Since Dart supports first-class functions and closures we can try to write a function that takes a function and returns another function that does the same thing, but adds memoization.<br /><br />Here's my first attempt:<br /><pre class="syntax" style="font-family: Courier New, Courier, monospace;">memoize1(f(x)) {<br />  var cache = new Map();<br />  m(x) {<br />    if (cache.containsKey(x)) {<br />      return cache[x];<br />    } else {<br />      var result = f(x);<br />      cache[x] = result;<br />      return result;<br />    }<br />  }<br />  return m;<br />}</pre>Line-by-line, <span style="font-family: Courier New, Courier, monospace;">memoize1</span> takes a function f as an argument, creates a cache, defines a function m which first checks the cache for an existing value and returns it if found, or it calculates the value, caches the result and then returns it. Finally <span style="font-family: Courier New, Courier, monospace;">memoize1</span> returns that new function.<br /><br /><span style="font-family: Courier New, Courier, monospace;">memoize1</span> is so named because it works for functions with one parameter. Dart lacks varargs as of now, so the wrapper function m must have a fixed number of arguments.&nbsp;<a href="http://www.dartlang.org/articles/emulating-functions/" target="_blank">Function emulation</a>&nbsp;would fix this, as would real vararg support.<br /><br />To use <span style="font-family: Courier New, Courier, monospace;">memoize1</span> we pass it a reference to fib like so:<br /><pre class="syntax" style="font-family: Courier New, Courier, monospace;">var fastfib = memoize1(fib);<br />var f40 = fastfib(40);</pre>Easy, right? The only problem is that <span style="font-family: Courier New, Courier, monospace;">fastfib(40)</span> still takes 41 seconds to run. Why? because even though the initial call to <span style="font-family: Courier New, Courier, monospace;">fastfib</span> uses the memoization wrapper, the recursive calls don't. They still call plain ol' <span style="font-family: Courier New, Courier, monospace;">fib</span>. Ouch.<br /><br />So what do we do? First let's consider how this works in other languages.<br /><br />One great thing about many dynamic languages (not to be confused with dynamic <i>programming</i>!) is that it's often relatively easy to modify code at runtime, which makes writing an automatic&nbsp;memoizer that works on recursive function possible.<br /><br />For instance, in a language where you can rebind a function name, like Ruby or Javascript, you rebind &nbsp;the original function name to a function that wraps the original and caches it's return values. Rebinding the name means that even the recursive calls in the function call the memoized version, not the original.<br /><br />In Python it's even easier because decorators capture calls to the function so that even rebinding isn't necessary.<br /><br />In a less dynamic* language like Dart we can't redefine a function and there are no decorators, so automatic memoization is much trickier. Mirrors and/or MirrorBuilders might help in the future, but they can't save us now.<br /><br /><span style="font-size: x-small;">* "dynamic language" is such an overloaded term that things get confusing. Dart is still dynamically&nbsp;typed, but it's less easy to redefine functions and classes or introduce new variables, so it's in some ways less dynamic that Python, Javascript or Ruby.</span><br /><h2>Designing for Memoization</h2>What we can do though is write our function specifically so that it's amenable to this type of transformation. In order to do that we can't hardcode our recursive calls anymore because we must allow them to be replaced.<br /><br />What we do is pass the function to itself as an argument. This looks weird, but it lets us pass in a wrapper instead of the original function and then the recursive calls will call the wrapper. I'm pretty sure this either is an example of some kind of combinator or was used to derive a combinator in a programming languages class a long time back... but unfortunately I forget now.<br /><br />Here's the code: <br /><pre class="syntax" style="font-family: 'Courier New', Courier, monospace;">int fib1(int f(f2, n2), int n) =&gt; (n &lt;= 1) ? n : f(f, n - 1) + f(f, n - 2);<br /><br />int fib(int n) =&gt; fib1(fib1, n);<br /><br />memoize1(f(f2, x)) {<br />  var cache = new Map();<br />  m(m2, x) {<br />    if (cache.containsKey(x)) {<br />      return cache[x];<br />    } else {<br />      var result = f(m2, x);<br />      cache[x] = result;<br />      return result;<br />    }<br />  }<br />  return (x) =&gt; m(m, x);<br />}<br /><br />main() {<br />  var fastfib = memoize(fib1);<br />  print(fib(40);<br />  print(fastfib(40));<br />}</pre><div><span style="font-family: Courier New, Courier, monospace;">fib1</span> is our modified Fibbonaci function that now takes two arguments: a function f with the same signature as fib1 that we use to make the recursive calls, and n the original argument.</div><div><br /></div><div><span style="font-family: Courier New, Courier, monospace;">fib</span> is the regular, easy-to-use, recursive Fibbonaci function that we create be passing&nbsp;<span style="font-family: Courier New, Courier, monospace;">fib1</span> to itself. The result is essentially the same as the original <span style="font-family: Courier New, Courier, monospace;">fib</span>.</div><br /><span style="font-family: inherit;">The new </span><span style="font-family: Courier New, Courier, monospace;">memoize1</span> still takes one argument, but that argument is now a memoizable single-argument function, such as <span style="font-family: Courier New, Courier, monospace;">fib1</span>. The wrapper <span style="font-family: Courier New, Courier, monospace;">m</span> takes a new argument, <span style="font-family: Courier New, Courier, monospace;">m2</span>, and now passes that to the recursive function so that when we pass the memoizing wrapper to itself, recursive calls call the wrapper and not the original function like before.<br /><br />Now when I run <span style="font-family: Courier New, Courier, monospace;">fastfib(40)</span> on my laptop it runs in 3ms. A little slower that <span style="font-family: Courier New, Courier, monospace;">dynamicfib</span><span style="font-family: inherit;">&nbsp;due to the wrapper, using a Map rather than a List, and the few recursive calls that are actually made, but still roughly a zillion times faster than the original. Importantly for this exercise, the new </span><span style="font-family: Courier New, Courier, monospace;">memoize1</span><span style="font-family: inherit;"> will work on any recursive function written to take itself as a parameter. Now someone could include a memoize function in a library and developers can write functions that they can easily speed up.</span><br /><h2>Reflections on Dart</h2>I'm not sure that automatic memoization is actually that useful - it's probably better to have a programmer really understand the implications of caching results - but I think this exercise points out a few areas where Dart could improve.<br /><br /><ul><li>Transforming functions is hard without varargs/kwargs. I suspect until then we'll see a bunch cases where a library has foo1, foo2, foo3 to transform functions with different arity. I'm not sure how transforming functions with key-word arguments could even work, except with apply() maybe.</li><li>It'd be nicer if developers didn't have to use the technique of passing a function to itself. I'm sure that's confusing to a lot of people. This is one reason I'd like to see Dart adopt <a href="http://en.wikipedia.org/wiki/Python_syntax_and_semantics#Decorators" target="_blank">Python-style decorators</a>, though with the arrival of the <span style="font-family: Courier New, Courier, monospace;">@</span> syntax for metadata, some thought would have to go into the syntax and how metadata and decorators co-exist.</li><li><span style="font-family: inherit;">This technique is probably not going to work well in checked mode, because we can't force the wrapper to have the same runtime type as the function we're transforming. Generic functions might help in some cases, but in the general case we won't be able to specify or capture all the type parameters that the original function uses.</span></li><li>It'd also be interesting to see how MirrorBuilders might come into play here. If it were possible to introspect the code of a function and transform it to build a new function, then we could memoize functions that we didn't even write. MirrorBuilders might not be possible in dart2js, but <a href="http://groovy.codehaus.org/Compile-time+Metaprogramming+-+AST+Transformations" target="_blank">Groovy's compile-time AST transformations</a> could be an inspiration here. We don't <i>need</i>&nbsp;to do the memoize transformation at runtime, if we could run the mirror system at compile time we could generate new code that the VM or dart2js each could use.</li></ul><br /><br />Well, I hope that was interesting to at least someone out there. If anything it was fun to investigate, and if I got anything wrong, please let me know!<br /><br />
