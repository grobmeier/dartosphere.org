---
title: '10 Punkte, in denen Dart JavaScript übertrifft'
layout: post
tags:
    - Beispiele
    - Frameworks
    - JavaScript
    - Syntax
category: null
published: '2012-01-12T16:37:46+00:00'

---

<p><a title="Dart" href="http://www.dartlang.org" target="_blank">Dart</a> ist eine von Google entwickelte Programmiersprache, die mittlerweile als Open Source Projekt verfügbar ist. Derzeit befindet sich die Sprache im technischen Preview und ist noch nicht produktiv zu verwenden, aber man kann schon prima damit rumspielen.</p>
<p>Aus Dart kann JavaScript generiert werden (ähnlich dem CoffeeScript Ansatz) oder es kann native im Browser laufen. Es gibt bereits Webkit- und Chrome-Branches, die genau jenes unterstützen sollen. Trotzdem: es wird noch einige Zeit vergehen, bis man wirklich von einer weiten &#8220;nativen&#8221; Unterstützun von Dart in den Browsern sprechen kann. Glücklicherweise kann man aus Dart ja auch JavaScript machen, weswegen die Sprache trotzdem interessant ist.</p>
<p>Aber warum das Ganze? JavaScript ist immerhin weit verbreitet und hat viele Anhänger gefunden. </p>
<p>Vor ca. einem Jahr begann ich mich ernsthaft mit JavaScript beschäftigen. Ich komme von der Java Welt und musste daher einiges lernen, bevor ich wirklich produktiv arbeiten konnte. Die Art zu Denken unterscheidet sich doch sehr zwischen Java und JavaScript. </p>
<p>Manche Leuten sagen, dass man sich besonders tief mit JavaScript beschäftigen muss, ansonsten könne man nicht über die Vor- und Nachteile diskutieren. Ich bin nun wirklich kein JavaScript Ninja. Aber ich glaube fest daran, dass eine Sprache leicht zu erlernen und leicht zu verstehen sein sollte. Zudem sollte eine Sprache konsequent sein, wenn es um Syntax und Konzepte geht. </p>
<p>Auch jetzt, nachdem ich bereits so lange Zeit mit JavaScript gearbeitet habe und dessen Schwächen kenne, muss ich leider sagen dass ich immer noch sehr, sehr, sehr vorsichtig arbeiten muss, wenn es um mein tägliches Brot geht. JavaScript hat ein paar sehr gute Ideen &#8211; aber trotzdem, die fehlende Sicherheit beim Entwickeln empfinde ich als sehr nachteilig. Eine Sprache sollte den Entwickler unterstützen &#8211; und nicht umgekehrt.</p>
<p>Ich habe im folgenden 10 Punkte aufgelistet, die mich besonders mit meiner täglichen JavaScript Arbeit beschäftigt haben und die jetzt mit Dart gelöst werden (sollen). Wegen ihnen &#8211; aber nicht nur &#8211; werde ich irgendwann zu Dart wechseln. Dabei darf man aber nicht vergessen, das Dart immer noch &#8220;in der Mache&#8221; ist, und sich somit noch einiges verändern kann. Ungefragt und jederzeit.</p>
<h3>1. Dart kennt nur einen &#8220;falsify&#8221; Wert</h3>
<p><a href="http://11heavens.com/falsy-and-truthy-in-javascript" target="_blank">In diesem Post</a> kann man recht schnell sehen was ich meine. Die Werte: false, null, undefined, &#8220;&#8221;, 0, NaN in JavaScript gelten als &#8220;false&#8221;. Das heißt, man kann solche Dinge machen:</p>
<pre class="brush: jscript; title: ; notranslate">
var a = null;
if(!a) {
   // do
}
</pre>
<p>In Dart gibt es nur einen Wert der &#8220;false&#8221; ist, nämlich &#8220;false&#8221; selbst. Natürlich muss man den Code dann etwas anders schreiben:</p>
<pre class="brush: java; title: ; notranslate">
var a = null;
if(a != null) {
   // do
}
</pre>
<p>6 verschiedene Ausdrücke die &#8220;false&#8221; ergeben &#8211; das muss man erstmal wissen.</p>
<h3>2. Dart arbeitet mit Typen, wenn man das will</h3>
<p>JavaScript Entwickler sagen oft, dass Typen die Flexibilität reduzieren. OK, das mag wahr sein. Aber zu viel Flexibilität reduziert auch die Qualität der Software ;-). Manchmal will man eben mit Typen arbeiten, und Dart erlaubt es einem, wenn man es möchte. Man muss einfach nur den Typechecker anschalten, schon kann man damit loslegen.</p>
<h3>3. Man braucht ein weiteres Framework in JS um gut mit dem DOM arbeiten zu können</h3>
<p>In JavaScript gibt es unsere alten Freunde:</p>
<pre class="brush: jscript; title: ; notranslate">
getElementsById()
getElementsByTagName()
getElementsByName()
getElementsByClassName()
querySelector()
querySelectorAll()
document.links
document.images
document.forms
document.scripts
formElement.elements
selectElement.options
</pre>
<p>Ganz schön viel. Glücklicherweise haben wir jQuery und Co, die uns aus dieser Geschichte raushelfen. Aber, sollte es heutzutage wirklich noch nötig sein ein extra Framework einzubinden, nur um mit dem DOM zu arbeiten? Eigentlich doch nicht.</p>
<p><a title="Improving the DOM" href="http://www.dartlang.org/articles/improving-the-dom/" target="_blank">Dart hat sich jQuery ansehen</a> und daraus genau zwei Methoden abgeleitet:</p>
<pre class="brush: java; title: ; notranslate">
elem.query('#foo');
elem.queryAll('.foo');
</pre>
<p>Besser.</p>
<h3>4. Klassen und Interfaces</h3>
<p>Wenn Java Entwickler mit JavaScript anfangen, versuchen sie oft JavaScript so zu programmieren, wie sie auch Java schreiben würden. Da gibt es dann Konstruktoren und klassenähnliche Elemente. Das ist aber nicht im Sinne des Erfinders und sollte anders gemacht werden: JavaScript ist eben Prototyp basiert, alles ist ein Objekt. Das ist ziemlich cool. Auf der anderen Seite kann man die Gang of Four Patterns weitgehend ausser Acht lassen und anstelle dessen ein Buch über JavaScript Patterns lesen.</p>
<p>Ich habe in meiner Laufbahn einige Entwickler getroffen, die bereits sehr lange Zeit benötigt haben um die gängigen Patterns zu verstehen. Nicht jeder ist ein Geek. Eine Sprache, die nicht mainstream ist, in einer mainstream-Umgebung zu verwenden führt geradewegs in das Zentrum des absoluten Chaos.</p>
<h3>5. Vererbung</h3>
<p><a href="http://www.2ality.com/2011/11/javascript-classes.html" target="_blank">Dr. Rauschmayer erklärt</a> in seinem ausgezeichneten Blogpost, warum JavaScript Vererbung einfach ist &#8211; und da hat er recht. Es ist wirklich einfach. Aber aufgepasst: dies ist nicht die einzige Art, wie man Vererbung durchführen kann. jQuery und das Prototype-Framework haben sogar eine extra &#8220;extend&#8221; Methode. Anstelle von dem von Dr. Rauschmayer empfohlenen __proto__ kann man <a href="http://www.bennadel.com/blog/1514-Extending-Classes-In-Object-Oriented-Javascript.htm" target="_blank">das prototype Keyword verwenden</a> (in diesem Post wird sogar von Klassen gesprochen, auch wenn es gar keine Klassen in JavaScript gibt). Natürlich kann man auch seinen<br />
<a href="http://andrewdupont.net/2009/08/28/deep-extending-objects-in-javascript/" target="_blank">eigenen Mechanismus entwickeln</a> und jede Eigenschaft einfach selbst kopieren.</p>
<p>Diese Seiten waren Suchergebnisse von Google, wenn man nach den Wörtern &#8220;javascript object extends&#8221; sucht. Es ist eigentlich ziemlich viel, was man lesen kann, obwohl es eigentlich nur ein recht einfaches Ziel zu erreichen gilt: Erweiterung.</p>
<p>Nicht jeder liest Dr. Rauschmayers Blog. Schade, denn das Leben wäre recht viel einfacher, falls das so wäre.</p>
<p>Dart kennt Klassen und kennt auch das &#8220;extends&#8221; Schlüsselwort. Ziemlich einfach.</p>
<p>ECMAScript 6 soll das übrigens bereinigen (Spec wird 2013 beendet werden).</p>
<h3>6. Globaler Namespace</h3>
<p>In JavaScript muss man aufpassen, damit man nicht einfach Zeugs in den globalen Namensraum legt. Das kann ehrlich gesagt ziemlich einfach passieren. Falls man ein &#8220;this&#8221; oder ein &#8220;var&#8221; vergisst, hat man Variablen auf globalen Level. Jedes Skript hat dann Zugriff darauf. Das ist eigentlich ziemlich schrecklich und sollte verhindert werden. Dank dem <a href="http://astore.amazon.de/neoteccde-21/detail/0596806752" target="_blank">Buch von Stoyan Stefanovs namens JavaScript Patterns</a> habe ich ein Pattern gelernt, wie man den Namensraum sauber halten kann. Jetzt geht es mir besser und ich habe wieder mehr Kontrolle über das, was ich tue. Leider brauche ich dafür ein Pattern. Das sollte eigentlich &#8220;out of the Box&#8221; geliefert werden.</p>
<p>In Dart entwickelt man im &#8220;Library&#8221; Scope. Das bedeutet, das Keyword &#8220;Library&#8221; verschließt ein Dart-&#8221;Paket&#8221; so, daß nur öffentliche Felder, Methoden und Klassen von außen zugänglich sind. Zusätztlich wird jedes Dart Skript als eigenes Isolate ausgeführt. Das heißt, es hat einen eigenen State und kann nicht auf den State der anderen Skripte zugreifen. Mit Dart muss man zwar immer noch über Sichtbarkeit und Bibliotheken nachdenken, aber es ist sehr viel einfacher und man braucht sicherlich auch kein Buch dafür. Anstelle davon sollte man eigentlich nur über &#8220;<a href="http://de.wikipedia.org/wiki/Cross-Cutting_Concern#Separation_of_Concerns" target="_blank">Separation of concerns</a>&#8221; nachdenken müssen.</p>
<h3>7. Dart kennt Nebenläufigkeit</h3>
<p>Mit JavaScript sind die Dinge nicht wirklich nebenläufig. Sogar wenn man einen asynchronen Zugriff mittels jQuery durchführt befindet man sich immer noch in einem &#8220;Thread&#8221;. Mit V8 scheinen die Dinge anders zu laufen, aber genaueres weiß ich darüber nicht. Umgehen kann man dieses Problem mit HTML5 und Webworkern.</p>
<p><a title="Dart Isolates" href="http://dartvader.grobmeier.de/dart-isolates-08112011.html" target="_blank">Dart kennt Isolates</a>. Das ist damit so ähnlich wie in Erlang. Isolates können miteinander kommunizieren. Wenn ein Isolate zusammenbricht, kann es neu gestartet werden. Das ist ziemlich cool. Natürlich machen Isolates Dart auch für die serverseitige Entwicklung interessant. Und ja, ich habe von Node.js gehört. Aber das ist nicht der Punkt: Dart kann das nämlich von sich aus.</p>
<h3>8. JavaScript kennt kein foreach.</h3>
<p>Aber moment.</p>
<p><a href="http://www.naden.de/blog/javascript-foreach" target="_new">Object oder Array.prototype kann erweitert werden.</a> Das ist natürlich nett.</p>
<p>Für Arrays kann man natürlich auch das machen:</p>
<pre class="brush: jscript; title: ; notranslate">
for (var i = 0; i &lt; elements.length; i++) {
  // do something
}
</pre>
<p>Und man kann das für Objekte machen:</p>
<pre class="brush: jscript; title: ; notranslate">
for (key in elements) {
  alert(elements[key]);
}
</pre>
<p>Douglas Crockford <a href="http://shop.oreilly.com/product/9780596517748.do">empfiehlt dies jedoch nicht.</a> Er sagt, die Ergebnisse sind nicht geordnet und man kann natürlich auch die Eigenschaften der prototyp-Kette sowie Funktionsnamen sehen. Die man wiederrum mit hasOwnProperty ausfiltern könnte.</p>
<p>Letztlich kann man natürlich auch in ein Framework wie jQuery sehen, die sowas wie forEach anbieten.</p>
<p>Zu guter letzt sei gesagt, das ECMAScript 5 foreach für Arrrays kennt. Zumindest alle modernen Browser unterstützen das also. <a href="http://kangax.github.com/es5-compat-table/">Dazu gehört der Internet Explorer 8 aber offensichtlich nicht</a> und der ist dummerweise noch im Einsatz.</p>
<p>In Dart:</p>
<pre class="brush: java; title: ; notranslate">
for (element in elements) {
  // do something
}
</pre>
<p>Das Leben ist damit entspannter. Damit iteriert man über eine Liste mit Elementen.</p>
<h3>9. Seltsames initialisieren von Arrays</h3>
<p><a href="http://c2.com/cgi/wiki?JavaScriptFlaws" target="_blank">Das habe ich mir ausgeliehen</a>. Man sehe sich folgendes an:</p>
<pre class="brush: jscript; title: ; notranslate">
var a1 = new Array(1,2,3,4,5);
var a2 = new Array(5);
</pre>
<p>a1 ist ein Array mit 5 Elementen: [1,2,3,4,5]<br />
a2 ist auch ein Array mit 5 Elementen: [undefined,undefined,undefined,undefined,undefined]</p>
<p><a href="http://blog.sethladd.com/2011/12/lists-and-arrays-in-dart.html" target="_blank">Dart ist da sauberer</a>. Ein Array ist hier einfach eine Liste und hat eben ein solches Interface.</p>
<pre class="brush: java; title: ; notranslate">
List a1 = [1,2,3,4,5];
List a2 = new List(5);
</pre>
<p>Auch hier enthält a1 fünf verscchiedene Elemente, a2 enthält nur den Platz für 5 Elemente.<br />
Zusätzlich bekommt man Methoden wie &#8220;removeRange&#8221; oder zur Sortierung, wie man in obigen link von Seth Ladd kann.</p>
<h3>10. undefined und null</h3>
<p>Es gibt viel zu lernen, wenn man mit JavaScript anfängt. Darunter ist die <a href="http://bonsaiden.github.com/JavaScript-Garden/#core.undefined" target="_blank">Weisheit, dass es nicht nur null gibt &#8211; sondern auch undefined</a>. Dabei handelt es sich um einen Typ mit nur einem Wert: undefined. Dieser kann überschrieben werden. Und den kann man quasi jederzeit bekommen, zum Beispiel wenn man return aufruft aber keinen Wert zurückgibt. Auf der verlinkten Seite kann man lesen, wie man mit undefined umgeht, wenn man sich vor einem versehentlichen Überschreiben schützen will.</p>
<p>In den meisten Fällen kann wohl null mit undefined ersetzt werden.</p>
<p>Das ist krank.</p>
<p>Dart kennt nur ein null.</p>
<h3>Zusammenfassung</h3>
<p>JavaScript hat natürlich auch seine guten Seiten. Es gibt einige sehr nette Patterns. Aber derzeit habe ich nichts gefunden, was ich nicht auch mit Dart machen könnte. Dart ist meistens eleganter und lesbarer (meiner Meinung nach). Natürlich werden einigen Hardcore-JavaScript Entwickler dem nicht zustimmen. Aber das ist OK. Man muß JavaScript mögen, wenn man damit arbeiten will. Dart dagegen ist Mainstream. Es gibt kaum böse Überraschungen.</p>
<p>PS: In meiner Liste habe ich die EventHandler vergessen, die in Dart sehr gelungen sind.</p>
<p>PPS: Außerdem habe ich die Verwirrung, die das this-Schlüsselwort in JavaScript bietet, vergessen. Vielleicht findet sich ja noch was für eine zweite Liste.</p>

