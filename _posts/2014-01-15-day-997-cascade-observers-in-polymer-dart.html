---
title: 'Day 997: Cascade Observers in Polymer (Dart)'
layout: post
tags:
    - chain
    - dart
    - dartlang
    - polymer
category: japhr-by-chris-strom
published: '2014-01-15T23:07:00-05:00'

---

<div class=top-chain-links></div><br />I am usually pretty safe assuming that my assumptions are wrong. Unless they're not. Happily, this turned out to be the case with some code I was trying to force in <a href="https://www.dartlang.org/polymer-dart/">Polymer.dart</a>. Thanks to a reimplementation in the JavaScript version of the <a href="http://www.polymer-project.org/">Polymer</a> project, I now have a better understanding of bound variables in Polymer.<br /><br />The problem arose when I tried to bind some <code>Pizza</code> model attributes in a <code>&lt;x-pizza></code> element:<pre class=prettyprint>&lt;link rel="import" href="../bower_components/polymer/polymer.html"><br />&lt;polymer-element name="x-pizza"><br />  &lt;template><br />    &lt;h2>Build Your Pizza&lt;/h2><br />    &lt;pre><br /><b>{{model.firstHalfToppings}}<br />{{model.secondHalfToppings}}</b>&lt;/pre><br />    &lt;!-- ... --><br />  &lt;/template><br />  &lt;script src="x_pizza.dart">&lt;/script><br />&lt;/polymer-element></pre>Those attributes were not bound, at least not such that their changes were observed in the template. Interestingly, when an actual bound attribute, say a “pizza state” instance variable, was bound in the same <code>&lt;pre></code> element in my template, then the model attributes were updated:<pre class="prettyprint">&lt;link rel="import" href="../bower_components/polymer/polymer.html"><br />&lt;polymer-element name="x-pizza"><br />  &lt;template><br />    &lt;h2>Build Your Pizza&lt;/h2><br />    &lt;pre><br /><b>{{pizzaState}}</b><br />{{model.firstHalfToppings}}<br />{{model.secondHalfToppings}}&lt;/pre><br />    &lt;!-- ... --><br />  &lt;/template><br />  &lt;script src="x_pizza.js">&lt;/script><br />&lt;/polymer-element></pre>In fact, the model attributes in the template were updated whenever the <code>pizzaState</code> instance variable was updated. So it seems that including a truly bound variable inside a tag will force all bound variables—model or element—to update. That seems useful information to file away for another day. <br /><br />For today, I would like to see how the JavaScript library's solution of path expressions to watch for changes in a model translates into <a href="http://dartlang.org">Dart</a>. From last night's JavaScript, the solution was to observe three list attributes in the model:<pre class="prettyprint">Polymer('x-pizza', {<br />  observe: {<br />    'model.firstHalfToppings': 'updatePizzaState',<br />    'model.secondHalfToppings': 'updatePizzaState',<br />    'model.wholeToppings': 'updatePizzaState'<br />  },<br />  // ...<br />});</pre>The <code>observe</code> block tells Polymer to call the <code>updatePizzaState()</code> method (which updates <code>pizzaState</code> for the template) whenever a change is seen in any of those lists.<br /><br />If there is an equivalent for the <code>observe</code> block in Polymer.dart, I cannot find it. <br /><br />What I wind up using instead is simple change listeners. For this to work, the model in my Model Driven View, <code>Pizza</code>, needs to be “observable.” Furthermore, since the properties in question are lists, I need a specialized “observable” instance of those lists. Both of these are established with judicious used of the <code>@observable</code> annotation:<pre class="prettyprint">@observable<br />class Pizza {<br />  List&lt;String> firstHalfToppings = toObservable([]);<br />  List&lt;String> secondHalfToppings = toObservable([]);<br />  List&lt;String> wholeToppings = toObservable([]);<br />}</pre>With that, I can create something that looks like an <code>observe</code> block. If you squint:<pre class=prettyprint>@CustomTag('x-pizza')<br />class XPizza extends PolymerElement {<br />  // ...<br />  Pizza model;<br /><br />  XPizza.created(): super.created() {<br /><b>    model = new Pizza()<br />      ..firstHalfToppings.changes.listen(updatePizzaState)<br />      ..secondHalfToppings.changes.listen(updatePizzaState)<br />      ..wholeToppings.changes.listen(updatePizzaState);</b><br />    // ...<br />  }<br /> // ...<br />}<br /></pre>The double dot operator in Dart is a method cascade. It returns the original object instead of the return value of the method (or property lookup). Above, this allows me to ask for the <code>firstHalfToppings</code>, <code>secondHalfToppings</code>, and <code>wholeToppings</code> properties from the newly created <code>Pizza</code> object. For each of these, I listen to the <code>changes</code> stream for a change and update the “pizza state” accordingly.<br /><br />And that does the trick:<br /><br /><a href="http://2.bp.blogspot.com/-yS9mYT95ElM/UtdY8-p4qsI/AAAAAAAAU14/ugMUp26jKwc/s1600/01-working_observe_block_cascade.png" imageanchor="1" ><img border="0" src="http://2.bp.blogspot.com/-yS9mYT95ElM/UtdY8-p4qsI/AAAAAAAAU14/ugMUp26jKwc/s640/01-working_observe_block_cascade.png" /></a><br /><br />I can live with that method cascade solution. At least for tonight. It is a solution (and a relatively clean one at that), but I am not 100% certain that it is <i>the</i> solution for this in Polymer.dart. While digging through class documentation, I came across Polymer's <code>bind()</code> and <code>bindProperty()</code> methods. Both use similar path expressions as those found in the JavaScript <code>observe</code> block. I am not entirely sure that they operate in the same problem space, but that is a topic for another day. Like tomorrow!<br /><br /><br /><span style="color: #ccc">Day #997</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/01/day-997-model-driven-views-in-polymer-js.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <a href="http://japhr.blogspot.com/2014/01/day-998-binding-to-model-changes-in.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script>
