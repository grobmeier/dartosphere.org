---
title: Webview
layout: post
tags: {  }
category: futureperfect.info
published: '2013-01-25T00:00:00+00:00'

---


<p>This is a story about <a href="http://pub.dartlang.org/packages/webview">Webview</a>, my first published <a href="http://pub.dartlang.org/packages/web_ui">web component</a>. I have been exploring the new <a href="https://developer.chrome.com/trunk/apps/about_apps.html">Chrome Apps</a> and I took an interesting in the <code>&lt;webview&gt;</code> element for embedding web content in Chrome applications. This custom element (which actually <em>is</em> a web component already!) interests me because I see a number of compelling use cases. The Chrome team themselves have put forth use cases such as the embedding of widgets (Google+, etc…) within applications. I’ll leave you and your imagination to consider the realm of possibilities!</p>

<h2 id="dart_exposure">Dart Exposure</h2>

<p>My <a href="http://pub.dartlang.org/packages/webview">Webview</a> package has one clear and simple objective: to expose this element and its API as a Dart type; a <a href="http://pub.dartlang.org/packages/web_ui">web component</a> to be precise. Being a web component allows you to use this element just like you would use the native <code>&lt;webview&gt;</code> element in your html, only with a slight twist to the tag name:</p>
<div class='highlight'><pre><code class='html'><span class='nt'>&lt;x</span><span class='na'>-webview</span> <span class='na'>src=</span><span class='s'>&quot;http://news.google.com/&quot;</span><span class='nt'>&gt;</span><span class='err'>&lt;</span>/x-webview&gt;
</code></pre>
</div>
<p>You can query the element from your Dart scripts to obtain an instance of the <code>Webview</code> type, and then listen to custom events and call methods to control the embedded content:</p>
<div class='highlight'><pre><code class='dart'><span class='kd'>var</span> <span class='n'>webview</span> <span class='o'>=</span> <span class='n'>document</span><span class='p'>.</span><span class='n'>query</span><span class='p'>(</span><span class='s1'>&#39;x-webview&#39;</span><span class='p'>).</span><span class='n'>xtag</span><span class='p'>;</span>
<span class='n'>webview</span><span class='p'>.</span><span class='n'>reload</span><span class='p'>();</span>
</code></pre>
</div>
<p>Now, of course, you could do all of this in javascript with the <code>&lt;webview&gt;</code> element, so there is nothing spectacular going on here. What I’ve done is to simply enable this technology in Dart so that Dart developers can be filled with the joys of writing Chrome Apps with <a href="http://pub.dartlang.org/packages/web_ui">web ui</a>, without everyone wrestling with the <a href="http://pub.dartlang.org/packages/js">js interop</a> themselves. Speaking of javascript, let’s consider more how this works.</p>

<h2 id="who_stripped_my_element">Who Stripped my Element?</h2>

<p>Okay, so you are probably thinking to yourself <em>“Didn’t he say that <code>&lt;webview&gt;</code> is already a web component? Do I really need this extra layer?”</em> Good question! I am hoping that someday this wrapper may not be necessary. It is within their reach for the Dart team to include a library within the Dart SDK to expose the Chrome Apps API, and some recent submits indicate that preliminary work on this may have already begun. But as of this writing, if you try this:</p>
<div class='highlight'><pre><code class='dart'><span class='kd'>var</span> <span class='n'>webview</span> <span class='o'>=</span> <span class='n'>document</span><span class='p'>.</span><span class='n'>query</span><span class='p'>(</span><span class='s1'>&#39;webview&#39;</span><span class='p'>)</span>
</code></pre>
</div>
<p>You will be given an instance of <code>UnknownElement</code>. Any events or methods that are unique to <code>&lt;webview&gt;</code> will not be available, and an attempt to invoke such a method will throw <code>NoSuchMethodError</code>.</p>

<p>Our only option for interacting with this element is therefore javascript. This presented me with my first chance to look closely at the <a href="http://pub.dartlang.org/packages/js">js interop</a> library, which is the Dart team’s official solution for this sort of thing. Overall, I think it is a nice solution. One hitch with using it for Chrome Apps is in regard to Content Security Policy (<a href="http://developer.chrome.com/extensions/contentSecurityPolicy.html">CSP</a>). Namely, the js interop library will first check if it has been loaded into the global context, and if <em>not</em> then it will inject itself as inline script. It is this last part, the inline script injection, that violates <a href="http://developer.chrome.com/extensions/contentSecurityPolicy.html">CSP</a>. The workaround is to include the js portion of the js interop library directly in your Chrome App <code>&lt;html&gt;</code>:</p>
<div class='highlight'><pre><code class='html'><span class='nt'>&lt;script </span><span class='na'>type=</span><span class='s'>&quot;text/javascript&quot;</span> 
        <span class='na'>src=</span><span class='s'>&quot;packages/js/dart_interop.js&quot;</span><span class='nt'>&gt;&lt;/script&gt;</span>
</code></pre>
</div>
<p>With the above <code>script</code> included in your document, you’ll be up and running.</p>

<p>So after getting to this point, I thought it was going to be a piece of cake to wrap the javascript API behind my <code>&lt;x-webview&gt;</code> component. My thought was that now I could simply query the <code>&lt;webview&gt;</code> child of my <code>&lt;x-webview&gt;</code> to obtain a <code>js.Proxy</code> in my Dart <code>Webview</code> class, and then forward method calls to the proxy:</p>
<div class='highlight'><pre><code class='dart'>    
<span class='kd'>class</span> <span class='nc'>Webview</span> <span class='kd'>extends</span> <span class='n'>WebComponent</span> <span class='p'>{</span>
  <span class='n'>js</span><span class='p'>.</span><span class='n'>Proxy</span> <span class='n'>_proxy</span><span class='p'>;</span>

  <span class='kt'>void</span> <span class='n'>inserted</span><span class='p'>()</span> <span class='p'>{</span>
    <span class='n'>_proxy</span> <span class='o'>=</span> <span class='n'>js</span><span class='p'>.</span><span class='n'>retain</span><span class='p'>(</span>
        <span class='n'>js</span><span class='p'>.</span><span class='n'>context</span><span class='p'>.</span><span class='n'>document</span><span class='p'>.</span><span class='n'>querySelector</span><span class='p'>(</span><span class='s1'>&#39;webview&#39;</span><span class='p'>));</span>
  <span class='p'>}</span>
     
  <span class='kt'>void</span> <span class='n'>back</span><span class='p'>()</span> <span class='o'>=&gt;</span> <span class='n'>js</span><span class='p'>.</span><span class='n'>scoped</span><span class='p'>(()</span> <span class='o'>=&gt;</span> <span class='n'>_proxy</span><span class='p'>.</span><span class='n'>back</span><span class='p'>());</span>    
  <span class='p'>...</span>
<span class='p'>}</span>
</code></pre>
</div>
<p>The hiccup with the above comes from my initial assumptions about this call:</p>
<div class='highlight'><pre><code class='dart'><span class='n'>js</span><span class='p'>.</span><span class='n'>context</span><span class='p'>.</span><span class='n'>document</span><span class='p'>.</span><span class='n'>querySelector</span><span class='p'>(</span><span class='s1'>&#39;webview&#39;</span><span class='p'>)</span>
</code></pre>
</div>
<p>A cursory reading of the <a href="http://dart-lang.github.com/js-interop/docs/js.html">documentation</a> for the js interop library yields:</p>

<p><em>“Note, parameters and return values are intuitively passed by value for primitives and by reference for non-primitives. In the latter case, the references are automatically wrapped and unwrapped as proxies by the library.”</em></p>

<p>After reading the above, I was inclined to expect the method call to <code>querySelector('webview')</code> to return an instance of <a href="http://dart-lang.github.com/js-interop/docs/js/Proxy.html">Proxy</a>. However, if we <code>print</code> the object that is returned by the query we see that was a false assumption:</p>

<pre><code>Instance of 'UnknownElement'</code></pre>

<p>As it turns out, the js interop library is treating elements as <em>primitives</em> in regards to parameters and return values that cross the language boundary. This makes sense and is what we’d want in most cases, but it is not overly clear from the <a href="http://dart-lang.github.com/js-interop/docs/js.html">documentation</a>. So, instead of a proxy to the <code>&lt;webview&gt;</code> element (which would allow us to use its API) we are presented with an object of type <code>UnknownElement</code>, which is more or less worthless to us for our use case.</p>

<h2 id="getting_dirty_in_javascript">Getting Dirty in Javascript</h2>

<p>I’ll start this paragraph with a confession: I have never written any javascript before embarking on this project. So I apologize in advance if my usage of said language brings tears to the eyes of the js veterans out there! But I knew that to get this job done I was going to have to roll up my sleeves. My goal was to define a wrapper type in javascript for my <code>&lt;webview&gt;</code> element, so that I could get a proxy to the wrapper in my Dart code and use that to forward method calls to the element in the javascript.</p>

<p>I knew people had invented various patterns to define <em>classes</em> in javascript, and after reading <a href="http://www.phpied.com/3-ways-to-define-a-javascript-class/">this article</a> and thinking a bit I went with their option 1.2, methods added to the prototype of a top-level function:</p>
<div class='highlight'><pre><code class='js'><span class='kd'>function</span> <span class='nx'>Webview</span><span class='p'>(</span><span class='nx'>e</span><span class='p'>,</span> <span class='nx'>url</span><span class='p'>,</span> <span class='nx'>onEvent</span><span class='p'>)</span> <span class='p'>{</span>  
  <span class='k'>this</span><span class='p'>.</span><span class='nx'>e</span> <span class='o'>=</span> <span class='nx'>e</span><span class='p'>;</span>  
  <span class='k'>this</span><span class='p'>.</span><span class='nx'>e</span><span class='p'>.</span><span class='nx'>addEventListener</span><span class='p'>(</span><span class='s1'>&#39;exit&#39;</span><span class='p'>,</span> <span class='nx'>onEvent</span><span class='p'>);</span>
  <span class='p'>...</span>
  <span class='k'>this</span><span class='p'>.</span><span class='nx'>e</span><span class='p'>.</span><span class='nx'>src</span> <span class='o'>=</span> <span class='nx'>url</span><span class='p'>;</span>
<span class='p'>}</span>

<span class='nx'>Webview</span><span class='p'>.</span><span class='nx'>prototype</span><span class='p'>.</span><span class='nx'>back</span> <span class='o'>=</span> <span class='kd'>function</span><span class='p'>()</span> <span class='p'>{</span> <span class='k'>this</span><span class='p'>.</span><span class='nx'>e</span><span class='p'>.</span><span class='nx'>back</span><span class='p'>();</span> <span class='p'>}</span>
<span class='p'>...</span>
</code></pre>
</div>
<p>As we see above, my <em>constructor</em> function takes an <code>element</code> (the <code>&lt;webview&gt;</code>), an <code>url</code> to set the initial <code>src</code> of the webview, and an <code>onEvent</code> callback to forward all of the element’s custom events to. I then add all of the methods to the prototype of this function. Et voila, that’s pretty much all there is to it! With this code in place, we can construct a proxy in our Dart web component to interact with the <code>&lt;webview&gt;</code> element. We do this from the <code>inserted()</code> lifecycle method of our component:</p>
<div class='highlight'><pre><code class='dart'><span class='kt'>void</span> <span class='n'>inserted</span><span class='p'>()</span> <span class='p'>{</span>
  <span class='n'>_inject</span><span class='p'>(()</span> <span class='p'>{</span>
    <span class='n'>js</span><span class='p'>.</span><span class='n'>scoped</span><span class='p'>(()</span> <span class='p'>{</span>
      <span class='n'>_onEvent</span> <span class='o'>=</span> <span class='k'>new</span> <span class='n'>js</span><span class='p'>.</span><span class='n'>Callback</span><span class='p'>.</span><span class='n'>many</span><span class='p'>(</span><span class='n'>_dispatch</span><span class='p'>);</span>
      <span class='n'>_webview</span> <span class='o'>=</span> <span class='n'>js</span><span class='p'>.</span><span class='n'>retain</span><span class='p'>(</span><span class='k'>new</span> <span class='n'>js</span><span class='p'>.</span><span class='n'>Proxy</span><span class='p'>(</span><span class='n'>js</span><span class='p'>.</span><span class='n'>context</span><span class='p'>.</span><span class='n'>Webview</span><span class='p'>,</span> 
          <span class='n'>children</span><span class='p'>[</span><span class='m'>1</span><span class='p'>],</span> <span class='n'>_src</span><span class='p'>,</span> <span class='n'>_onEvent</span><span class='p'>));</span>
    <span class='p'>});</span>
    <span class='p'>...</span>
  <span class='p'>});</span>
<span class='p'>}</span>
</code></pre>
</div>
<p>Above, <code>children[1]</code> is the <code>&lt;webview&gt;</code> that is a child of the <code>&lt;x-webview&gt;</code> (our Dart web component). We handle all of the proxied custom events in a private method called <code>_dispatch</code>, which basically just re-dispatches them as custom events on the <code>&lt;x-webview&gt;</code> element. The <code>_inject(f)</code> method above is where things get interesting.</p>

<h3 id="injecting_the_script">Injecting the Script</h3>

<p>As we just saw above, in the <code>inserted()</code> method of the web component we are passing an anonymous function to a method named <code>_inject</code>. Why are we doing this? Simply put, we need to ensure that the javascript we wrote in the last section gets injected in the document and evaluated before we can construct a proxy or make any calls to that javascript.</p>

<p>We <em>could</em> just force all users of <code>&lt;x-webview&gt;</code> to add the following to their application’s html:</p>
<div class='highlight'><pre><code class='html'><span class='nt'>&lt;script </span><span class='na'>type=</span><span class='s'>&quot;text/javascript&quot;</span> 
        <span class='na'>src=</span><span class='s'>&quot;packages/webview/webview.js&quot;</span><span class='nt'>&gt;&lt;/script&gt;</span>
</code></pre>
</div>
<p>That would work, and in fact I do want to support this use case. You’ll see that this is what I do in the <a href="https://github.com/rmsmith/webview/tree/master/example/messaging">Messaging</a> example. But, I felt that I should try to encapsulate this implementation detail of the <code>&lt;x-webview&gt;</code> component.</p>

<p>My first instinct was to simply include the <code>&lt;script type=&quot;text/javascript&quot;&gt;</code> element directly in the html template for my web component. However, this does not work because the contents of the element’s <code>&lt;template&gt;</code> is injected into the document using <code>innerHtml</code> and thus the script is not evaluated. Placing the <code>&lt;script&gt;</code> anywhere else in the <code>&lt;element&gt;</code> of the web component’s html results in its removal by the <code>dwc</code> compiler, so at this point I felt stuck and wrote a <a href="https://github.com/dart-lang/web-ui/issues/293">bug report</a>.</p>

<p>The solution actually came to me after browsing some other issues in the web ui project and seeing how they were planning to reference the <code>dart.js</code> script from the new <em>browser</em> package. I realized I could simply inject such a <code>&lt;script&gt;</code> element into the document from the Dart code of my <code>&lt;x-webview&gt;</code> if necessary, and using the <code>src=&quot;packages/webview/webview.js&quot;</code> means it should resolve correctly from any entry point that is using <a href="http://pub.dartlang.org">Pub</a>, which is pretty much every Dart application these days.</p>

<p><strong>Warning</strong> I do my work on Windows 7, 64-bit. I have seen others mention that perhaps symlinks (e.g. <code>packages/</code>) do not resolve in Chrome Apps developer mode on some platforms (linux, osx). I do not have any means to confirm or deny this, but I can say that they do work on Windows (with junctions).</p>

<p>The implementation of our <code>_inject(then)</code> method follows as:</p>
<div class='highlight'><pre><code class='dart'><span class='c1'>// First we check if the javascript is already injected</span>
<span class='p'>...</span>
<span class='c1'>// Webview.js is not yet injected, so append it to body.</span>
<span class='kd'>var</span> <span class='n'>script</span> <span class='o'>=</span> <span class='k'>new</span> <span class='n'>ScriptElement</span><span class='p'>();</span>
<span class='n'>script</span><span class='p'>.</span><span class='n'>type</span> <span class='o'>=</span> <span class='s2'>&quot;text/javascript&quot;</span><span class='p'>;</span>
<span class='n'>script</span><span class='p'>.</span><span class='n'>src</span> <span class='o'>=</span> <span class='s2'>&quot;packages/webview/webview.js&quot;</span><span class='p'>;</span>
<span class='n'>script</span><span class='p'>.</span><span class='n'>on</span><span class='p'>.</span><span class='n'>load</span><span class='p'>.</span><span class='n'>add</span><span class='p'>((</span><span class='n'>e</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='c1'>// Script loaded, check support and continue.</span>
  <span class='n'>_supported</span> <span class='o'>=</span> <span class='n'>js</span><span class='p'>.</span><span class='n'>scoped</span><span class='p'>(()</span> <span class='o'>=&gt;</span> 
  <span class='n'>js</span><span class='p'>.</span><span class='n'>context</span><span class='p'>.</span><span class='n'>isWebviewSupported</span><span class='p'>());</span>
  <span class='n'>then</span><span class='p'>();</span>
<span class='p'>});</span>    
<span class='n'>document</span><span class='p'>.</span><span class='n'>body</span><span class='p'>.</span><span class='n'>append</span><span class='p'>(</span><span class='n'>script</span><span class='p'>);</span>
</code></pre>
</div>
<p>Notice that we first check if the javascript is already injected. This covers two different cases:</p>

<p>1) The user instantiates more than one instance of <code>&lt;x-webview&gt;</code>; We only need a single javascript for <em>n</em> instances of our component.</p>

<p>2) The user explicitly adds the <code>&lt;script&gt;</code> to their html <code>&lt;body&gt;</code>; This is a valid use case, especially if the user wants to ensure the script is available immediately. As we see above in the implementation of <code>_inject</code>, appending the <code>&lt;script&gt;</code> to the <code>&lt;body&gt;</code> is an <em>asynchronous</em> operation and the continuation <code>then()</code> is not invoked until the script finishes loading. So the API of the <code>&lt;x-webview&gt;</code> may not be available until some time after the web component is inserted in the document, unless the user takes this measure.</p>

<p>No more magic, the rest of the component’s <a href="https://github.com/rmsmith/webview/blob/master/lib/webview.dart">implementation</a> should be straightforward to follow.</p>

<h2 id="a_pattern_to_follow_or_bugs_to_file">A Pattern to Follow or Bugs to File?</h2>

<p>I hope that this article has provoked some thought in both the reader and the writer about whether or not all of this was a good idea. I’m not sure I would like to promote any of the workarounds in this article as generally good patterns to follow, but this may help if you are in a pinch to add some javascript behavior to a Dart web component. I think some of this may translate into issue tracker reports, but i’m not sure what plans the Dart team might have up their sleeves regarding <a href="https://developer.chrome.com/trunk/apps/about_apps.html">Chrome Apps</a>; it is possible this exercise might only be a short term solution. The use case of attaching some javascript behavior to a Dart web component may or may not be useful in other contexts. I believe many other cases are solveable directly with the <a href="http://pub.dartlang.org/packages/js">js interop</a> library.</p>

<p>I’d love to get feedback from others who have faced or solved similar problems. Enjoy all the goodness of <a href="http://www.dartlang.org">Dart</a>, <a href="https://developer.chrome.com/trunk/apps/about_apps.html">Chrome Apps</a>, and <a href="http://pub.dartlang.org/packages/web_ui">web ui</a>!</p>

