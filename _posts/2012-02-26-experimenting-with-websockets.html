---
title: 'Experimenting with WebSockets'
layout: post
tags: {  }
category: dartery
published: '2012-02-26T17:46:00-08:00'

---

This is just some notes and a preview of what will probably be a more in-depth post on WebSockets in Dart. Between GWT compiles over the past few days I've been trying to get a simple WebSocket client/server app up and running. Going in, I didn't know anything about WebSockets other than that they're bidirectional and as close to raw sockets as you can get in a browser.<br /><br />Unfortunately, I've never done any raw TCP work, unless it was in school and I forgot already, so once I got to data framing and saw how much work it'd be to implement the RFC I quickly hit my time allowance for this excursion. Yay for higher-level protocols like HTTP and all the implementations I've used over the years. Working higher on the stack has it's advantages, but from a pure cranial exercise point-of-view, it does arguably shield you too much from what's happening underneath.<br /><br />But... I do have a simple echo WebSocket server up and running, using the http library from the Chat sample (with a few tweaks) to handle the handshake.<br /><br />There were a few noteworthy lessons along the way:<br /><ol><li>WebSockets were broken in Dart for a while. The WebSocket constructor just landed in bleeding_edge, but it only works in Frog, not in Dartium.&nbsp;</li><li>I didn't know about the handshake, and the <a href="http://dev.w3.org/html5/websockets/">W3C draft spec</a> doesn't really cover it. Chrome also doesn't give much indication of anything going wrong when the server simply doesn't send a handshake response. I'm not sure it could, other than timeout, but that was confusing. Reading the <a href="http://tools.ietf.org/html/rfc6455">RFC</a> and <a href="http://en.wikipedia.org/wiki/WebSocket">Wikipedia</a> helped.</li><li>ws://echo.websocket.org was helpful to check that the client code worked.&nbsp;</li><li>I needed base64 encode and SHA1 digest functions. I took a base64 encode function from the Total sample and modified it to work with lists of int and to pad the output correctly, and I got SHA1 from <a href="http://code.google.com/p/dart-crypto-lib/">dart-crypto-lib</a>.</li><li>I initially tried to base64 encode the hex string digest from SHA1 until I figured out I need to encode the raw byte array digest. Oops.</li><li>Once I had what I thought was a correct handshake response, debugging why the handshake wasn't working was quite a pain because Chrome wouldn't let me see the response headers if they weren't correct and Firefox doesn't have a WebSocket() constructor.&nbsp;</li><li>To fix Firefox I added a script that assigned WebSocket to MozWebSocket. This let me use Firebug to see the response headers from my server.&nbsp;</li><li>I didn't use the HTTP server from Chat, but I used an HTTPConnection attached to a ServerSocket, so that I could remove the handlers from the HTTPConnection after the handshake completed and have a raw socket again.</li><li>HTTPConnection didn't let me set the HTTP status, so I added it to the interface.&nbsp;</li><li>HTTPConnection also wanted to set the connection header to closed, so I had to add a check to not set the header if it was already set to "Upgrade".</li><li>I tried to decode messages on the server with the utf8 library, but that failed because I hadn't yet read about <a href="http://tools.ietf.org/html/rfc6455#section-5">framing</a>. Oops again.</li></ol>As of now, I can echo a received message back to the client, but I'm pretty sure this only works because the message is small and fits in one frame. Parsing and constructing frames is obviously key to building even the simplest WebSocket server. The client API exposed in browsers is comparatively simple to use, it's a shame there isn't a simpler bi-directional HTTP-based protocol, like an <a href="http://dev.w3.org/html5/eventsource/">EventSource</a> that can also send messages from browser to server.<br /><br />It shouldn't be too hard from here to implement the framing and wrap everything up into a WebSocket server that takes care of the handshake, parses frames, and exposes a simpler interface with handlers for text and binary messages. It'd be really nice to have this built in to a future http library.<br /><br />I'll post some code next time around, but hopefully these notes help anyone else playing around with WebSockets in Dart.<br /><br />Happy Darting!
