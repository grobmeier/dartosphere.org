---
title: 'Humor: Metamocking'
layout: post
tags:
    - dartlang
    - humor
    - 'software engineering'
    - testing
category: jjinuxland
published: '2012-11-17T14:25:00-08:00'

---

<div dir="ltr" style="text-align: left;" trbidi="on"><p>There are a lot of very powerful concepts in the world of software engineering that  have "meta" in their name. Just consider metaprogramming and metaclasses. I've spent some time thinking about what "metamocking" might look like. What would it mean to mock a mock?</p> <p>First, some background. Let's say I have the following function (written in Dart):</p> <pre>void helloWorld() {<br />  print("Hello, World!");<br />}</pre> <p>How do I know if it works correctly? Since it doesn't return anything, but rather changes the state of the outside world (specifically, the stuff printed to my terminal), it's not so easy to test.</p> <p>Mocking to the rescue! I need to add a bit of dependency injection so that the test can pass in its own code for printing and so that I can mock things properly:</p> <pre>library hello_world;<br /><br />const defaultPrinter = const Printer();<br /><br />class Printer {<br />  const Printer();<br />  printValue(String s) => print(s);<br />}<br /><br />void helloWorld({Printer printer: defaultPrinter}) {<br />  printer.printValue("Hello, World!");<br />}<br /><br />main() {<br />  helloWorld();<br />}</pre> <p>Now, let's write a unittest that makes use of mocking to test the helloWorld function:</p> <pre>import 'package:unittest/unittest.dart';<br /><br />import 'hello_world.dart';<br /><br />class PrinterSpy extends Mock implements Printer {<br />  PrinterSpy() {<br />    when(callsTo('printValue', "Hello, World!")).thenReturn(true);<br />  }<br />}<br /><br />void main() {<br />  group('helloWorld', () {<br />    test('prints "Hello, world!"', () {<br />      var printerSpy = new PrinterSpy();<br />      helloWorld(printer: printerSpy);<br />      printerSpy.getLogs(callsTo('printValue'))<br />        .verify(happenedExactly(1))<br />        .verify(alwaysReturned(true));<br />    });<br />  });<br />}</pre> <p>Woah! That's a lot of code to test such a simple function! I feel pretty comfortable about "class PrinterSpy" because it's pretty short, but I'm really worried about the test itself. How do I know that the test itself is using printerSpy correctly?</p> <p>Once again, mocking to the rescue! Let me start by pulling out the heart of the test into a separate function so that I can make use of dependency injection again:</p> <pre>import 'package:unittest/unittest.dart';<br /><br />import 'hello_world.dart';<br /><br />class PrinterSpy extends Mock implements Printer {<br />  PrinterSpy() {<br />    when(callsTo('printValue', "Hello, World!")).thenReturn(true);<br />  }<br />}<br /><br />void testPrintsHelloWorld({PrinterSpy printerSpy}) {<br />  if (!?printerSpy) {  <br />    printerSpy = new PrinterSpy();<br />  }<br />  helloWorld(printer: printerSpy);<br />  printerSpy.getLogs(callsTo('printValue'))<br />    ..verify(happenedExactly(1))<br />    ..verify(alwaysReturned(true));<br />}<br /><br />void main() {<br />  group('helloWorld', () {<br />    test('prints "Hello, world!"', () => testPrintsHelloWorld());<br />  });<br />}</pre> <p>Now, I can create a mock for my mock to make sure that I wrote it correctly. Unfortunately, this is fairly challenging since you can't use a Mock to mock a method named getLogs since Mock has its own definition of that function. Nonetheless:</p> <pre>import 'package:unittest/unittest.dart';<br /><br />import 'hello_world.dart';<br /><br />class PrinterSpy extends Mock implements Printer {<br />  PrinterSpy() {<br />    when(callsTo('printValue', "Hello, World!")).thenReturn(true);<br />  }<br />}<br /><br />void testPrintsHelloWorld({PrinterSpy printerSpy}) {<br />  if (!?printerSpy) {  <br />    printerSpy = new PrinterSpy();<br />  }<br />  helloWorld(printer: printerSpy);<br />  printerSpy.getLogs(callsTo('printValue'))<br />    ..verify(happenedExactly(1))<br />    ..verify(alwaysReturned(true));<br />}<br /><br />class PrinterSpySpy extends PrinterSpy {<br />  LogEntryList getLogs([CallMatcher logFilter,<br />                        Matcher actionMatcher,<br />                        bool destructive = false]) {<br />    log.add(new LogEntry(null, "getLogs",<br />        [logFilter, actionMatcher, destructive], null));<br />    return super.getLogs(logFilter, actionMatcher, destructive);<br />  }<br />}<br /><br />void testTestPrintsHelloWorld() {<br />  var printerSpySpy = new PrinterSpySpy();<br />  testPrintsHelloWorld(printerSpy: printerSpySpy);<br />  printerSpySpy.getLogs(callsTo('getLogs')).verify(happenedExactly(2));<br /><br />  // Verifying the number of times verify is called is left as an<br />  // exercise for the reader.<br />}<br /><br />void main() {<br />  group('helloWorld', () {<br />    test('prints "Hello, world!"', () => testPrintsHelloWorld());<br />  });<br />  <br />  group('testPrintsHelloWorld', () {<br />    test('uses printerSpy correctly', () => testTestPrintsHelloWorld());      <br />  });<br />}</pre> <p>As you can see, I was able to verify that my mock executed correctly. Metamocking is certainly an interesting, albeit advanced technique for software engineers who consider themselves true experts in the art of software testing.</p> <p>However, I should mention that it does have a couple flaws. For instance, who's to say that the mock for my mock is itself correct? In theory, running a mock should serve to test the mock, but one can never be too sure! Furthermore, despite the fact that I've written a lot of test code, I have no idea if helloWorld will truly print "Hello, World!" to my terminal since I never tested the actual print function. Mocking is like that sometimes ;)</p> <p>At this point, I should probably wrap up. I'll finish with a proper definition of metamocking. The astute reader may have guessed by now that metamocking (i.e. mock mocking) actually has two meanings:</p> <ul><li>To create mock objects in order to test your mock objects.</li><li>To mock (i.e. poke fun at) those people who rely on mocking too much :)</li></ul> <p>My next blog post will be on metametamocking. In it, I plan on mocking this blog post and explaining that it was just a hopelessly bad and overly elaborate pun ;)</p></div>
