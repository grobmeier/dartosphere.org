---
title: Bench
layout: post
tags: {  }
category: futureperfect.info
published: '2012-11-29T00:00:00+00:00'

---


<p>This is the story of <a href="http://pub.dartlang.org/packages/bench">Bench</a>, my first <a href="http://pub.dartlang.org">Pub</a> package. It started about a month ago, when there was quite a lot of chatter on the <a href="https://groups.google.com/a/dartlang.org/forum/?fromgroups#!forum/misc">mailing list</a> about benchmarks, how to warm up the VM, etc… This was also right after M1, the first official milestone release of the Dart language. I have been interested in mirror reflection since first learning about Dart, and watching this excellent <a href="http://www.hpi.uni-potsdam.de/hirschfeld/events/past/media/100105_Bracha_2010_LinguisticReflectionViaMirrors_HPI.mp4">presentation</a> by Gilad Bracha. So, I decided to write Bench to both learn the <a href="http://api.dartlang.org/docs/bleeding_edge/dart_mirrors.html">mirror API</a> and to try and help the community.</p>

<h2 id="mostly_just_a_harness">Mostly Just a Harness</h2>

<p>I’m accustomed to using test runners such as <a href="http://www.nunit.org/">NUnit</a> in my daily work. This framework, along with many others like it, uses reflection to discover all of your tests to be executed. This makes life easy for you the developer, as you can focus on writing the test cases themselves and need not worry about wiring things up in a harness manually. In NUnit, the discovery of test cases is done through C# attributes, akin to annotations in Dart.</p>

<p>Here is a simple example of an NUnit test fixture with a single test case:</p>
<div class='highlight'><pre><code class='csharp'><span class='na'>[TestFixture]</span>
<span class='k'>public</span> <span class='k'>class</span> <span class='nc'>MyTests</span>
<span class='p'>{</span>
<span class='na'>  [SetUp]</span>
  <span class='k'>public</span> <span class='k'>void</span> <span class='nf'>Init</span><span class='p'>()</span>
  <span class='p'>{</span>
    <span class='c1'>// TODO:</span>
  <span class='p'>}</span>

<span class='na'>  [Test]</span>
  <span class='k'>public</span> <span class='k'>void</span> <span class='nf'>TestTheTruth</span><span class='p'>()</span>
  <span class='p'>{</span>
    <span class='n'>Assert</span><span class='p'>.</span><span class='n'>IsTrue</span><span class='p'>(</span><span class='k'>true</span><span class='p'>);</span>
  <span class='p'>}</span>
<span class='p'>}</span>
</code></pre>
</div>
<p>To run the above test fixture, you would typically build your C# assembly (library) and then pass it as a command line argument to the NUnit test runner. Or, you could load your assembly in the NUnit GUI test runner, and interact with the UI to run or debug any subset of your test cases. All of this behavior of the test runner is made possible through reflection. The test runner will detect the attributes (annotations) ‘TestFixture’, ‘SetUp’ and ‘Test’ and use them as cues.</p>

<p>Naturally, when I first started thinking about Bench I looked to this prior art for inspiration. However, I quickly noted a fundamental difference between Dart and C# (or Java for that matter) - the fact that in Dart we have top-level functions.</p>

<p>When you are writing a benchmark, you are interested in the performance of a particular algorithm. That algorithm may be implemented with a set of classes, or it may be implemented simply as a set of functions. Either way, there is going to be a single method call that serves as the entry point to your performance critical code path. There might also be some setup required, in terms of instantiating some objects or other work that you would like to do prior to the measurement of your benchmark. But do we really need to write a class to express that? I believe that in Dart we don’t need to.</p>

<p>Let’s consider a simple example:</p>
<div class='highlight'><pre><code class='dart'><span class='n'>Benchmark</span> <span class='n'>affineTransformScale</span><span class='p'>()</span> <span class='p'>{</span>    
  <span class='kd'>var</span> <span class='n'>tx</span> <span class='o'>=</span> <span class='k'>new</span> <span class='n'>AffineTransform</span><span class='p'>(</span><span class='m'>1</span><span class='p'>,</span> <span class='m'>2</span><span class='p'>,</span> <span class='m'>3</span><span class='p'>,</span> <span class='m'>4</span><span class='p'>,</span> <span class='m'>5</span><span class='p'>,</span> <span class='m'>6</span><span class='p'>);</span>
  <span class='k'>return</span> <span class='k'>new</span> <span class='n'>Benchmark</span><span class='p'>(()</span> <span class='o'>=&gt;</span> <span class='n'>tx</span><span class='p'>.</span><span class='n'>scale</span><span class='p'>(</span><span class='m'>2</span><span class='p'>,</span> <span class='m'>3</span><span class='p'>));</span>
<span class='p'>}</span>
</code></pre>
</div>
<p>Here we have a top-level function named <em>affineTransformScale</em> that returns a value of type <em>Benchmark</em>. The <em>Benchmark</em> class is defined in Bench and in our example above we are creating one via the following constructor:</p>
<div class='highlight'><pre><code class='dart'><span class='n'>Benchmark</span><span class='p'>(</span><span class='kt'>void</span> <span class='n'>method</span><span class='p'>(),</span> 
          <span class='p'>{</span><span class='nl'>description:</span><span class='s2'>&quot;&quot;</span><span class='p'>,</span> <span class='nl'>measure:</span><span class='m'>100</span><span class='p'>,</span> <span class='nl'>warmup:</span><span class='m'>200</span><span class='p'>})</span> 
</code></pre>
</div>
<p>Notice that the only required argument is the <em>method</em> that serves as the entry point to your benchmark algorithm. In our example we are providing a closure over the method call <em>tx.scale(2, 3)</em> for the <em>method</em>. Bench will invoke this <em>method</em> for the configured number of <em>measure</em> and <em>warmup</em> iterations, which have default values as shown above.</p>

<p>What about the body of the <em>affineTransformScale</em> function? It made sense for me to use this scope for the <em>setup</em> of the benchmark. Unlike what we saw above in the NUnit example, there is no reason to pass any information to the <em>Benchmark</em> regarding your setup routine. Instead, we can use mirror reflection to execute the body of the <em>affineTransformScale</em> function and you can therefore write your setup code directly here. We should not care that we are using reflection to invoke the setup code, as this code is not being measured for performance. I found this to be an elegant solution and in practice it feels quite natural to me. In our example, we are using the setup scope to create an instance of an <em>AffineTransform</em> for use in the benchmark:</p>
<div class='highlight'><pre><code class='dart'><span class='kd'>var</span> <span class='n'>tx</span> <span class='o'>=</span> <span class='k'>new</span> <span class='n'>AffineTransform</span><span class='p'>(</span><span class='m'>1</span><span class='p'>,</span> <span class='m'>2</span><span class='p'>,</span> <span class='m'>3</span><span class='p'>,</span> <span class='m'>4</span><span class='p'>,</span> <span class='m'>5</span><span class='p'>,</span> <span class='m'>6</span><span class='p'>);</span>
</code></pre>
</div>
<p>We want to do this in our setup, so that the cost of constructing the transform does not play a part in the benchmark. This means our benchmark will only be measuring the performance of the <em>scale</em> method, which is what we want.</p>

<h3 id="runtime_algorithm">Runtime Algorithm</h3>

<p>So now let’s look more formally at the algorithm Bench uses to discover and execute benchmarks such as the <em>affineTransformScale</em> example. The library provides a <em>Benchmarker</em> class that you use to run the harness:</p>
<div class='highlight'><pre><code class='dart'><span class='kt'>void</span> <span class='n'>main</span><span class='p'>()</span> <span class='p'>{</span>
  <span class='k'>new</span> <span class='n'>Benchmarker</span><span class='p'>().</span><span class='n'>run</span><span class='p'>();</span>
<span class='p'>}</span>
</code></pre>
</div>
<p>The <em>Benchmarker</em> may be configured in a number of ways, but in its most basic usage looks as it does above. When you call <em>run</em>, the benchmarker will perform the following:</p>

<ol>
<li>
<p>Obtain the current <a href="http://api.dartlang.org/docs/bleeding_edge/dart_mirrors/MirrorSystem.html">MirrorSystem</a>.</p>
</li>

<li>
<p>Create a <em>BenchmarkResult</em> to store the result of this <em>run</em>.</p>
</li>

<li>
<p>For each library (optionally filtered) in the current isolate:</p>

<ol>
<li>
<p>Create a <em>BenchmarkLibrary</em> to store metadata about the library’s benchmarks.</p>
</li>

<li>
<p>For each top-level function in the library:</p>

<ol>
<li>
<p>If the function has zero parameters and a return type of <em>Benchmark</em>:</p>

<ol>
<li>
<p>Invoke the function to perform the <em>setup</em> scope.</p>
</li>

<li>
<p>Store the returned <em>Benchmark</em> in <em>BenchmarkLibrary.benchmarks</em>.</p>
</li>
</ol>
</li>
</ol>
</li>

<li>
<p>If <em>BenchmarkLibrary.benchmarks</em> is not empty then add it to <em>BenchmarkResult.libraries</em>.</p>
</li>
</ol>
</li>

<li>
<p>For each library in <em>BenchmarkResult.libraries</em>:</p>

<ol>
<li>For each benchmark in <em>BenchmarkLibrary.benchmarks</em>:
<ol>
<li>
<p>Perform <em>Benchmark.warmup</em> number of invocations of <em>Benchmark.method</em>.</p>
</li>

<li>
<p><em>Start</em> the benchmark’s <a href="http://api.dartlang.org/docs/bleeding_edge/dart_core/Stopwatch.html">Stopwatch</a>.</p>
</li>

<li>
<p>Perform <em>Benchmark.measure</em> number of invocations of <em>Benchmark.method</em>.</p>
</li>

<li>
<p><em>Stop</em> the benchmark’s Stopwatch.</p>
</li>
</ol>
</li>
</ol>
</li>

<li>
<p>Pass the <em>BenchmarkResult</em> to the registered <em>BenchmarkHandler</em> if any.</p>
</li>

<li>
<p>Complete the <em>run</em> with the <em>BenchmarkResult</em>.</p>
</li>
</ol>

<h3 id="parsing_the_result">Parsing the Result</h3>

<p>Running the <em>Benchmarker</em> on our example <em>affineTransformScale</em> will yield the following:</p>

<pre><code>initializing isolate: affinity_bench.dart/main-7113
running benchmarks...
affinity_bench.affineTransformScale : (36 ms / 10000 iterations) = 0.0036</code></pre>

<p>The above output is from the default <em>BenchmarkHandler</em> which simply logs the result using the Dart SDK’s <a href="http://api.dartlang.org/docs/bleeding_edge/logging.html">logging</a> library. You may define your own <em>BenchmarkHandler</em> function and pass it to <em>Benchmarker.run</em> to perform custom parsing of the <em>BenchmarkResult</em>, or you may receive the <em>BenchmarkResult</em> as follows:</p>
<div class='highlight'><pre><code class='dart'><span class='k'>new</span> <span class='n'>Benchmarker</span><span class='p'>().</span><span class='n'>run</span><span class='p'>().</span><span class='n'>then</span><span class='p'>((</span><span class='n'>result</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='c1'>// perform some custom parsing of the BenchmarkResult</span>
<span class='p'>}</span>
</code></pre>
</div>
<h2 id="lessons_learned">Lessons Learned</h2>

<p>I set out with a goal to learn about Dart’s mirror system. Although Bench only exercises a small portion of the available functionality, I spent a considerable amount of time exploring the documentation and code, and trying out various things.</p>

<h3 id="runtime_type_vs_typemirror">Runtime Type vs. TypeMirror</h3>

<p>One concrete problem that I encountered in Bench, was in regard to checking the return type of top-level functions to determine if they return a <em>Benchmark</em> or not. My logic to determine if your top-level function is one that Bench cares about is as follows, where <em>method</em> is an instance of <em>MethodMirror</em>:</p>
<div class='highlight'><pre><code class='dart'><span class='k'>if</span><span class='p'>(</span><span class='n'>method</span><span class='p'>.</span><span class='n'>isTopLevel</span> 
  <span class='o'>&amp;&amp;</span> <span class='n'>method</span><span class='p'>.</span><span class='n'>parameters</span><span class='p'>.</span><span class='n'>length</span> <span class='o'>==</span> <span class='m'>0</span>
  <span class='o'>&amp;&amp;</span> <span class='n'>method</span><span class='p'>.</span><span class='n'>returnType</span> <span class='k'>is</span> <span class='n'>ClassMirror</span>
  <span class='o'>&amp;&amp;</span> <span class='n'>method</span><span class='p'>.</span><span class='n'>returnType</span><span class='p'>.</span><span class='n'>qualifiedName</span> <span class='o'>==</span> <span class='s1'>&#39;bench.Benchmark&#39;</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='c1'>// it is a function we care about</span>
<span class='p'>}</span>
</code></pre>
</div>
<p>As you can see, I am checking the qualified name of the <em>returnType</em> and doing a string comparison. I would feel much better if I were able to do something like:</p>
<div class='highlight'><pre><code class='dart'><span class='n'>TypeMirror</span> <span class='n'>benchmarkType</span> <span class='o'>=</span> 
    <span class='n'>reflect</span><span class='p'>(</span><span class='k'>new</span> <span class='n'>Benchmark</span><span class='p'>(()</span> <span class='o'>=&gt;</span> <span class='p'>{}).</span><span class='n'>runtimeType</span><span class='p'>);</span>

<span class='k'>if</span><span class='p'>(</span><span class='n'>method</span><span class='p'>.</span><span class='n'>isTopLevel</span> 
    <span class='o'>&amp;&amp;</span> <span class='n'>method</span><span class='p'>.</span><span class='n'>parameters</span><span class='p'>.</span><span class='n'>length</span> <span class='o'>==</span> <span class='m'>0</span>
    <span class='o'>&amp;&amp;</span> <span class='n'>method</span><span class='p'>.</span><span class='n'>returnType</span> <span class='o'>==</span> <span class='n'>benchmarkType</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='c1'>// it is a function we care about</span>
<span class='p'>}</span>
</code></pre>
</div>
<p>Fortunately, I am not the only person interested in this and <a href="http://code.google.com/p/dart/issues/detail?id=6433">an issue</a> exists in the tracker, so please star it if you think this is a good idea.</p>

<h3 id="stepping_through_the_futures">Stepping Through the Futures</h3>

<p>A big chunk of my development time on Bench was spent wrapping my brain around <a href="http://api.dartlang.org/docs/bleeding_edge/dart_core/Future.html">Futures</a>, as much of the mirrors API uses them. I understand why this is so, and I do not intend to ask for a synchronous API. I embrace the asynchrony, but I find the current state of futures difficult to use. Luckily again, the Dart team is well aware of this and there is plenty of <a href="https://groups.google.com/a/dartlang.org/forum/#!topic/misc/Boch2XH9Tmk">work being done</a> to improve the asynchronous APIs in the core libraries.</p>

<p>The thing about futures is that when you encounter a method that returns one, that means your entire callstack above that method all the way to your entry point <em>should</em> be using futures. So knowing and appreciating that, it means that pretty much all of Bench needs to be written with futures.</p>

<p>One pattern that kept recurring in my code, was the need to iterate with Futures. For example, when I want to run all of the benchmarks in a given <em>BenchmarkLibrary</em> I do the following:</p>
<div class='highlight'><pre><code class='dart'><span class='n'>Future</span> <span class='n'>_run</span><span class='p'>()</span> <span class='p'>{</span>
  <span class='kd'>var</span> <span class='n'>completer</span> <span class='o'>=</span> <span class='k'>new</span> <span class='n'>Completer</span><span class='p'>();</span>
  <span class='n'>_iterateAsync</span><span class='p'>(</span><span class='n'>benchmarks</span><span class='p'>.</span><span class='n'>iterator</span><span class='p'>(),</span> <span class='p'>(</span><span class='n'>benchmark</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='kd'>var</span> <span class='n'>advance</span> <span class='o'>=</span> <span class='k'>new</span> <span class='n'>Completer</span><span class='o'>&lt;</span><span class='kt'>bool</span><span class='o'>&gt;</span><span class='p'>();</span>
    <span class='n'>_logger</span><span class='p'>.</span><span class='n'>fine</span><span class='p'>(</span><span class='s1'>&#39;running benchmark: </span><span class='si'>${</span><span class='n'>benchmark</span><span class='p'>.</span><span class='n'>methodName</span><span class='si'>}</span><span class='s1'>&#39;</span><span class='p'>);</span>
    <span class='n'>benchmark</span><span class='p'>.</span><span class='n'>_run</span><span class='p'>().</span><span class='n'>then</span><span class='p'>((</span><span class='n'>x</span><span class='p'>)</span> <span class='o'>=&gt;</span> <span class='n'>advance</span><span class='p'>.</span><span class='n'>complete</span><span class='p'>(</span><span class='kc'>true</span><span class='p'>));</span>
    <span class='k'>return</span> <span class='n'>advance</span><span class='p'>.</span><span class='n'>future</span><span class='p'>;</span>
  <span class='p'>}).</span><span class='n'>then</span><span class='p'>((</span><span class='n'>x</span><span class='p'>)</span> <span class='o'>=&gt;</span> <span class='n'>completer</span><span class='p'>.</span><span class='n'>complete</span><span class='p'>(</span><span class='kc'>null</span><span class='p'>));</span> 
  <span class='k'>return</span> <span class='n'>completer</span><span class='p'>.</span><span class='n'>future</span><span class='p'>;</span>
<span class='p'>}</span>
</code></pre>
</div>
<p>The above looks much nicer than what I originally had, because I ended up writing the <em>iterateAsync</em> helper function:</p>
<div class='highlight'><pre><code class='dart'><span class='c1'>/// A convenience function for asynchronous iteration.</span>
<span class='n'>Future</span> <span class='n'>_iterateAsync</span><span class='p'>(</span><span class='n'>Iterator</span> <span class='n'>it</span><span class='p'>,</span> <span class='n'>Future</span><span class='o'>&lt;</span><span class='kt'>bool</span><span class='o'>&gt;</span> <span class='n'>body</span><span class='p'>(</span><span class='n'>item</span><span class='p'>))</span> <span class='p'>{</span>
  <span class='kd'>var</span> <span class='n'>completer</span> <span class='o'>=</span> <span class='k'>new</span> <span class='n'>Completer</span><span class='p'>();</span>
  <span class='k'>if</span><span class='p'>(</span><span class='o'>!</span><span class='n'>it</span><span class='p'>.</span><span class='n'>hasNext</span><span class='p'>)</span> <span class='n'>completer</span><span class='p'>.</span><span class='n'>complete</span><span class='p'>(</span><span class='kc'>null</span><span class='p'>);</span>
  <span class='k'>else</span> <span class='n'>body</span><span class='p'>(</span><span class='n'>it</span><span class='p'>.</span><span class='n'>next</span><span class='p'>()).</span><span class='n'>then</span><span class='p'>((</span><span class='n'>advance</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='k'>if</span><span class='p'>(</span><span class='n'>advance</span><span class='p'>)</span> <span class='n'>_iterateAsync</span><span class='p'>(</span><span class='n'>it</span><span class='p'>,</span> <span class='n'>body</span><span class='p'>)</span>
        <span class='p'>.</span><span class='n'>then</span><span class='p'>((</span><span class='n'>x</span><span class='p'>)</span> <span class='o'>=&gt;</span> <span class='n'>completer</span><span class='p'>.</span><span class='n'>complete</span><span class='p'>(</span><span class='kc'>null</span><span class='p'>));</span>
    <span class='k'>else</span> <span class='n'>completer</span><span class='p'>.</span><span class='n'>complete</span><span class='p'>(</span><span class='kc'>null</span><span class='p'>);</span>
  <span class='p'>});</span>
  <span class='k'>return</span> <span class='n'>completer</span><span class='p'>.</span><span class='n'>future</span><span class='p'>;</span>
<span class='p'>}</span> 
</code></pre>
</div>
<p>I find myself using this function in other projects now, so I believe there should probably be something in the Dart SDK to address this.</p>

<h2 id="happy_benchmarking">Happy Benchmarking!</h2>

<p>That’s my story about <a href="http://pub.dartlang.org/packages/bench">Bench</a>. I don’t know if anyone will ever use it, and with the recent release of the <a href="http://pub.dartlang.org/packages/benchmark_harness">official benchmark harness</a> perhaps nobody should. There could well be some fundamental flaw that renders it useless, but I’d be curious and happy to receive any feedback from the Dart team or community. Either way, I hope people continue to write more benchmarks for the Dart VM. I have enjoyed seeing the performance of my own benchmarks written with Bench improving with each release of the Dark SDK.</p>

