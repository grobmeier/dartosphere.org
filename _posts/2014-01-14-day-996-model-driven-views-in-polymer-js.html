---
title: 'Day 996: Model Driven Views in Polymer (JS)'
layout: post
tags:
    - chain
    - dart
    - dartlang
    - javascript
    - mdv
    - polymer
category: japhr-by-chris-strom
published: '2014-01-14T23:59:00-05:00'

---

<div class=top-chain-links></div><br />I <i>adore</i> switching back and forth between the JavaScript version of <a href="http://www.polymer-project.org/">Polymer</a> and <a href="https://www.dartlang.org/polymer-dart/">Polymer.dart</a>. It has been a fantastic feedback mechanism for validating or, more frequently, disproving my thinking about Polymer. Tonight, I switch back to the JavaScript in the hopes that I can solidify my thinking on model driven views in Polymer.<br /><br />In my Dart version, I have a <code>&lt;x-pizza></code> Polymer that builds up a pizza for order. It looks something like:<br /><br /><a href="http://3.bp.blogspot.com/-RAts1S2A260/UtXdAvkLqAI/AAAAAAAAU1I/GLC4CBoc6tk/s1600/01-pizza_model.png" imageanchor="1" ><img border="0" src="http://3.bp.blogspot.com/-RAts1S2A260/UtXdAvkLqAI/AAAAAAAAU1I/GLC4CBoc6tk/s640/01-pizza_model.png" /></a><br /><br />And it works. More or less.<br /><br />One thing that I was not quite able to figure out was why model attributes—specifically list model attributes—were not updating the values bound in templates. For instance, the <code>model.firstHalfToppings</code> and <code>model.secondHalfToppings</code> values are not being updated in the template when they change in the model:<pre class=prettyprint>&lt;polymer-element name="x-pizza"><br />  &lt;template><br />    &lt;h2>Build Your Pizza&lt;/h2><br />    &lt;pre><br /><b>{{model.firstHalfToppings}}<br />{{model.secondHalfToppings}}</b>&lt;/pre><br />    &lt;!-- ... --><br />&lt;/template></pre>So let's see if I can make that work in a JavaScript version. Starting with the <code>index.html</code> page that contains my soon-to-exist-js-polymer:<pre class="prettyprint">&lt;head><br />  &lt;!-- 1. Load Polymer before any code that touches the DOM. --><br />  &lt;script src="bower_components/platform/platform.js">&lt;/script><br />  &lt;!-- 2. Load component(s) --><br />  &lt;link rel="import" href="elements/x-pizza.html"><br />&lt;/head><br />&lt;body><br />  &lt;div class="container"><br />    &lt;h1>JS Bros. Pizza Builder&lt;/h1><br /><b>    &lt;x-pizza>&lt;/x-pizza></b><br />  &lt;/div><br />&lt;/body></pre>The template that goes into the imported <code>x-pizza-html</code> is nearly identical to the Dart version. What changes is, obviously, the script tag—which now points to a JavaScript version of the Polymer class:<pre class=prettyprint>&lt;link rel="import" href="../bower_components/polymer/polymer.html"><br />&lt;polymer-element name="x-pizza"><br />  &lt;template><br />    &lt;h2>Build Your Pizza&lt;/h2><br />    &lt;pre><br />{{model.firstHalfToppings}}<br />{{model.secondHalfToppings}}&lt;/pre><br />  &lt;!-- ... --><br />  &lt;/template><br /><b>  &lt;script src="x_pizza.js">&lt;/script></b><br />&lt;/polymer-element></pre>There is nothing too out of the ordinary in that backing Polymer class—just the model assignment in the <code>ready()</code> lifecycle method:<pre class="prettyprint">Polymer('x-pizza', {<br />  ready: function() {<br /><b>    this.model = {<br />      firstHalfToppings: []<br />    };</b><br />  },<br />  addFirstHalf: function() {<br /><b>    this.model.firstHalfToppings.push(this.currentFirstHalf);</b><br />  },<br />  // ...<br />});</pre>The <a href="http://www.polymer-project.org/polymer.html#binding-objects-to-attribute-values">Polymer documentation</a> recommends binding the model in <code>ready()</code> to avoid shared prototype state (ah, JavaScript). <br /><br />In addition to assigning the model, I also define a bound method that adds records to the <code>firstHalfToppings</code> list property of the model. Whenever this function is called, the model's <code>firstHalfToppings</code> should change, which should update in the template. Only it did not in the Dart version of the Polymer.<br /><br />And it does not in the JavaScript version either:<br /><br /><a href="http://3.bp.blogspot.com/-V1o0ncvzobk/UtYS5hExfKI/AAAAAAAAU1Y/TfD_aokI8gA/s1600/01-not_updating_model_list_property.png" imageanchor="1" ><img border="0" src="http://3.bp.blogspot.com/-V1o0ncvzobk/UtYS5hExfKI/AAAAAAAAU1Y/TfD_aokI8gA/s640/01-not_updating_model_list_property.png" /></a><br /><br />No matter how often I click that button, the variable bound in that template never updates.<br /><br />Interestingly, if I create a string attribute directly on my Polymer and update it whenever the <code>addFirstHalf()</code> method is called:<pre class="prettyprint">Polymer('x-pizza', {<br />  ready: function() {<br />    this.model = {<br />      firstHalfToppings: [],<br />      secondHalfToppings: []<br />    };<br />  },<br /><b>  pizzaState: '',</b><br />  addFirstHalf: function() {<br />    this.model.firstHalfToppings.push(this.currentFirstHalf);<br /><b>    this.pizzaState = this.model.firstHalfToppings.join(',');</b><br />  },<br />  // ...<br />});</pre><i>And</i> if I bind this variable into the template inside the same tag as my list model attribute:<pre class=prettyprint>&lt;link rel="import" href="../bower_components/polymer/polymer.html"><br />&lt;polymer-element name="x-pizza"><br />  &lt;template><br />    &lt;h2>Build Your Pizza&lt;/h2><br />    &lt;pre><br /><b>{{pizzaState}}</b><br />{{model.firstHalfToppings}}<br />{{model.secondHalfToppings}}&lt;/pre><br />    &lt;!-- ... --><br />  &lt;/template><br />  &lt;script src="x_pizza.js">&lt;/script><br />&lt;/polymer-element></pre>Then, not only is the new bound variable updated in the template each time that method is called, but the list model attribute is also updated:<br /><br /><a href="http://4.bp.blogspot.com/-toiIwDzA-qI/UtYUfcqq9eI/AAAAAAAAU1k/kWdd8_XWxYw/s1600/02-bound_regular_attr_updated.png" imageanchor="1" ><img border="0" src="http://4.bp.blogspot.com/-toiIwDzA-qI/UtYUfcqq9eI/AAAAAAAAU1k/kWdd8_XWxYw/s640/02-bound_regular_attr_updated.png" /></a><br /><br />So it seems that the Dart version was behaving correctly. Or at least consistently.<br /><br />The last thing that I try tonight is observing the list properties of the model. If nothing else, I would like to have single place to accumulate changes. This turns out to be fairly easy with Polymer's observe property:<pre class=prettyprint>Polymer('x-pizza', {<br />  ready: function() {<br />    this.model = {<br />      firstHalfToppings: [],<br />      secondHalfToppings: []<br />    };<br />  },<br /><b>  observe: {<br />    'model.firstHalfToppings': 'updatePizzaState',<br />    'model.secondHalfToppings': 'updatePizzaState'<br />  },</b><br />  updatePizzaState: function() {<br />    this.pizzaState = this.model.firstHalfToppings.join(',') + "\n" +<br />      this.model.secondHalfToppings.join(',');<br />  },<br />  // ...<br />});</pre>The path expressions that serve as keys in the <code>observe</code> property establish change listeners for the specified properties. Polymer is able to resolve those strings into objects and properties, listening to the appropriate event source for a change. And, when a change does occur, the <code>updatePizzaStat</code> method is invoked.<br /><br />That works just fine. I think I am fairly close to fully understanding this approach and how Polymer wants it done. I may switch back to Polymer tomorrow to make certain.<br /><br /><br /><span style="color: #ccc">Day #996</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/01/day-995-observing-model-attributes-in.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <a href="http://japhr.blogspot.com/2014/01/day-997-cascade-observers-in-polymer.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script>
