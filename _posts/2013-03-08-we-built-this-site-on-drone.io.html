---
title: 'We Built This Site On Drone.io'
layout: post
tags: {  }
category: futureperfect.info
published: '2013-03-08T00:00:00+00:00'

---


<p>I have been using <a href="https://drone.io/">drone.io</a> since I encountered it as a <a href="http://www.dartlang.org">Dartisan</a> and I must say I have been nothing but pleased with it. It has risen up as <em>the</em> solution for continuous integration in the Dart community. As I was working on improving this site, I discovered another way in which drone.io can bring me joy.</p>

<p>Like many others these days, I host this site with Github Pages and use Jekyll to statically generate the content. You can read more about that <a href="https://help.github.com/articles/using-jekyll-with-pages">here</a>, but in this post I’m going to assume you are already familiar with the basics of this setup.</p>

<p>A common issue that developers face with this setup, is that Github Pages runs Jeykll with the following options:</p>

<pre><code>$ jekyll --pygments --no-lsi --safe</code></pre>

<p>It is that last option above, <code>--safe</code>, which can cause a lot of heartache. It makes sense for Github, as allowing plugins to execute on their servers exposes an obvious security loophole. However, as a hacker with good intentions who wants all the joy of executing plugins such as <a href="http://sass-lang.com/">sass</a> conversion, this may cause you sadness. I spent some time researching what others were doing to circumvent this, and I found the following solutions:</p>

<ol>
<li>Simply perform plugin tasks offline and submit the processed files to Github Pages.</li>

<li>Create a <code>source</code> branch in your repo where you submit your source content (the input to Jekyll) and then push the processed files to <code>master</code> for publishing; use a <code>.nojekyll</code> file on <code>master</code> to prevent Github Pages from re-running Jekyll.</li>
</ol>

<p>Option #1 is pretty simple and self-explanatory. If you don’t publish very often or you don’t mind the manual curation required, it isn’t such a bad option. It seems that many people are doing it this way.</p>

<p>Option #2 was more intruiging to me; I like the clean separation of input files and output files on the two branches. I found that people are using a variety of different solutions to get the input from their <code>source</code> branch to the output on their <code>master</code> branch. Mostly, it seems they are doing this ‘offline’ with different shell scripts, batch files, commit hooks, etc… I was looking for something similar, but I wanted an automated process that would consume my <code>source</code> content, run Jekyll unshackled, and then produce my <code>master</code> content. That is when I thought of drone.io.</p>

<p>I checked and saw that drone.io supports <a href="http://www.ruby-lang.org">ruby</a> and knew that it might just work. Drone supports a <code>Repository -&gt; Branch Filter</code> setting, so I setup my <code>source</code> branch to be the default branch for my repo in Github and then I also added <code>source</code> to the <code>Branch Filter</code> in my drone.io settings. This means that drone will only monitor commits to my <code>source</code> branch to trigger builds, which is what I want. Drone will automatically do a <code>git checkout</code> on the <code>source</code> branch based on these settings, so my build commands start from that point:</p>

<pre><code>sudo easy_install Pygments
bundle install
bundle exec jekyll
git checkout master
cd _site/
cp -r . ..
cd ../
git add -A
git commit -m&quot;auto commit from drone&quot;
git remote set-url origin git@github.com:rmsmith/rmsmith.github.com.git
git push origin master  </code></pre>

<p>First, we make sure that Pygments is installed. Jekyll uses Pygments, which is installed as a Python egg, for syntax highlighting. If you don’t need that, you can skip that command. Next we run <code>bundle install</code>, which is going to install all of the Ruby Gems in your <code>Gemfile</code>. This is important, you’ll need to have a <code>Gemfile</code> in your <code>source</code> branch of your repo that contains Jekyll at a minimum:</p>

<pre><code>source :rubygems

gem &quot;jekyll&quot;, &quot;~&gt; 0.11.2&quot; # we need at least this version so jekyll will use Ruby 1.9.2
gem &quot;sass&quot;, &quot;~&gt; 3.2.6&quot;</code></pre>

<p>You’ll notice that my <code>Gemfile</code> also includes ‘sass’, since the sass to css converter plugin is my motivation for this entire exercise.</p>

<p>After running Jekyll, we see the shell commands to copy the contents of the <code>_site/</code> directory to the top-level directory of the <code>master</code> branch. The <code>_site/</code> directory is in my <code>.gitignore</code> file so that is never pushed to either branch. This means that it will only exist locally on the build server as the output of running Jekyll. We then use git commands to add and commit the output files on the <code>master</code> branch. Before we can push the commit back to origin, we need to make sure that SSH is setup.</p>

<p>To allow drone.io to push back to your Github repo, you’ll need to set up SSH. In drone, you can find the SSH key under <code>Repository -&gt; View Key</code>. Then, in Github go to your <code>Account Settings -&gt; SSH Keys</code> and add this as a new key. This can only be configured in Github at the granularity of your entire user / organization account, so be aware that this gives drone.io push access to all of your repositories.</p>

<p>With SSH keys configured, the last two commands do the git magic to push the commits from drone.io on the <code>master</code> branch back up to the origin Github repository.</p>

<p>Now you can add the drone.io badge to your site’s README file like <a href="https://github.com/rmsmith/rmsmith.github.com">I did</a>, and be filled with joy as you work exclusively on your <code>source</code> branch with your source content.</p>

